use crate::prelude::*;
use crate::{
    SQL, SQLColumnInfo, SQLConstraintInfo, SQLForeignKeyInfo, SQLParam, SQLPrimaryKeyInfo,
    SQLSchema, SQLSchemaType, ToSQL,
};
use core::any::Any;

/// Marker: no fields have been set on this update model.
pub struct Empty;
/// Marker: at least one field has been set on this update model.
pub struct NonEmpty;

/// Type-level name marker used for strongly-typed aliases/CTEs.
pub trait Tag {
    const NAME: &'static str;
}

/// Trait implemented by generated runtime alias table types that can be tagged.
pub trait TaggableAlias: Sized {
    type Tagged<Name: Tag>;
    fn tag<Name: Tag>(self) -> Self::Tagged<Name>;
}

#[diagnostic::on_unimplemented(
    message = "`{Self}` is not a SQL model (Select, Insert, or Update)",
    label = "this type cannot be used as a query model"
)]
pub trait SQLModel<'a, V: SQLParam>: ToSQL<'a, V> {
    /// Columns referenced by this model.
    /// Static models can return a borrowed slice; dynamic models can allocate.
    fn columns(&self) -> Cow<'static, [&'static dyn SQLColumnInfo]>;
    fn values(&self) -> SQL<'a, V>;
}

/// Trait for models that support partial selection of fields
#[diagnostic::on_unimplemented(
    message = "`{Self}` does not support partial field selection",
    label = "this table's Select model does not implement SQLPartial"
)]
pub trait SQLPartial<'a, Value: SQLParam> {
    /// The type representing a partial model where all fields are optional
    /// for selective querying
    type Partial: SQLModel<'a, Value> + Default + 'a;

    fn partial() -> Self::Partial {
        Default::default()
    }
}

#[diagnostic::on_unimplemented(
    message = "`{Self}` is not a SQL table for this dialect",
    label = "ensure this type was derived with #[SQLiteTable] or #[PostgresTable]"
)]
pub trait SQLTable<'a, Type: SQLSchemaType, Value: SQLParam + 'a>:
    SQLSchema<'a, Type, Value> + SQLTableInfo + Default + Clone
{
    type Select: SQLModel<'a, Value> + SQLPartial<'a, Value> + Default + 'a;
    type ForeignKeys;
    type PrimaryKey;
    type Constraints;

    /// The type representing a model for INSERT operations on this table.
    /// Uses PhantomData with tuple markers to track which fields are set
    type Insert<T>: SQLModel<'a, Value> + Default;

    /// The type representing a model for UPDATE operations on this table.
    /// This would be generated by the table macro.
    type Update: SQLModel<'a, Value> + 'a;

    /// The aliased version of this table for self-joins and CTEs.
    /// For a table `Users`, this would be `AliasedUsers`.
    type Aliased: SQLTable<'a, Type, Value>;

    /// Creates an aliased version of this table with the given runtime name.
    /// Primarily used by internal builders (e.g., CTE construction).
    fn alias_named(name: &'static str) -> Self::Aliased;
}

pub trait SQLTableInfo: Any + Send + Sync {
    /// Unqualified table name.
    fn name(&self) -> &str;

    /// Optional schema/catalog namespace for this table.
    fn schema(&self) -> Option<&str> {
        None
    }

    /// Fully-qualified table name when schema is present.
    fn qualified_name(&self) -> Cow<'static, str> {
        match self.schema() {
            Some(schema) => Cow::Owned(format!("{schema}.{}", self.name())),
            None => Cow::Owned(self.name().to_string()),
        }
    }

    fn columns(&self) -> &'static [&'static dyn SQLColumnInfo];
    fn primary_key(&self) -> Option<&'static dyn SQLPrimaryKeyInfo> {
        None
    }
    fn foreign_keys(&self) -> &'static [&'static dyn SQLForeignKeyInfo] {
        &[]
    }
    fn constraints(&self) -> &'static [&'static dyn SQLConstraintInfo] {
        &[]
    }
    fn dependencies(&self) -> &'static [&'static dyn SQLTableInfo];

    /// Lookup a column by name.
    fn column_named(&self, name: &str) -> Option<&'static dyn SQLColumnInfo> {
        self.columns()
            .iter()
            .copied()
            .find(|col| col.name() == name)
    }
}

/// Implemented by concrete table structs to expose a canonical static instance.
pub trait SQLStaticTableInfo: SQLTableInfo + Sized + 'static {
    fn static_table() -> &'static Self;
}

// Blanket implementation for static references
impl<T: SQLTableInfo> SQLTableInfo for &'static T {
    fn name(&self) -> &str {
        (*self).name()
    }

    fn schema(&self) -> Option<&str> {
        (*self).schema()
    }

    fn qualified_name(&self) -> Cow<'static, str> {
        (*self).qualified_name()
    }

    fn columns(&self) -> &'static [&'static dyn SQLColumnInfo] {
        (*self).columns()
    }

    fn primary_key(&self) -> Option<&'static dyn SQLPrimaryKeyInfo> {
        (*self).primary_key()
    }

    fn foreign_keys(&self) -> &'static [&'static dyn SQLForeignKeyInfo] {
        (*self).foreign_keys()
    }

    fn constraints(&self) -> &'static [&'static dyn SQLConstraintInfo] {
        (*self).constraints()
    }

    fn dependencies(&self) -> &'static [&'static dyn SQLTableInfo] {
        (*self).dependencies()
    }
}

impl core::fmt::Debug for dyn SQLTableInfo {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("SQLTableInfo")
            .field("name", &self.name())
            .field("schema", &self.schema())
            .field("qualified_name", &self.qualified_name())
            .field("columns", &self.columns())
            .field("primary_key", &self.primary_key().map(|pk| pk.columns()))
            .field("constraints", &self.constraints().len())
            .finish()
    }
}
