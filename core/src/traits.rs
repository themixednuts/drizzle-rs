use std::any::Any;
mod tuple;

use crate::{SQLSchemaType, ToSQL};

/// A marker trait for types that can be used as SQL parameters.
///
/// This trait is used as a bound on the parameter type in SQL fragments.
/// It ensures type safety when building SQL queries with parameters.
pub trait SQLParam: Clone + std::fmt::Debug {}

// Implement SQLParam for common types
impl SQLParam for String {}
impl SQLParam for &str {}
impl SQLParam for i8 {}
impl SQLParam for i16 {}
impl SQLParam for i32 {}
impl SQLParam for i64 {}
impl SQLParam for isize {}
impl SQLParam for u8 {}
impl SQLParam for u16 {}
impl SQLParam for u32 {}
impl SQLParam for u64 {}
impl SQLParam for usize {}
impl SQLParam for f32 {}
impl SQLParam for f64 {}
impl SQLParam for bool {}
impl<T: SQLParam> SQLParam for Option<T> {}
impl<T: SQLParam> SQLParam for Vec<T> {}
impl<T: SQLParam> SQLParam for &[T] {}
impl<T: SQLParam> SQLParam for &T {}
impl<const N: usize, T: SQLParam> SQLParam for [T; N] {}

pub trait SQLSchema<'a, T> {
    const NAME: &'a str;
    const TYPE: T;
    const SQL: &'a str;
}

pub trait SQLColumnInfo: Any {
    fn is_not_null(&self) -> bool;
    fn is_primary_key(&self) -> bool;
    fn is_unique(&self) -> bool;
    fn name(&self) -> &str;
    fn r#type(&self) -> &str;
    fn table(&self) -> Box<dyn SQLTableInfo>;
}

pub trait SQLColumn<'a, Value: SQLParam>:
    SQLColumnInfo + Default + ToSQL<'a, Value> + SQLSchema<'a, &'a str>
{
    type Table: SQLTable<'a, Value>;
    type Type: TryInto<Value>;

    const PRIMARY_KEY: bool = false;
    const NOT_NULL: bool = false;
    const UNIQUE: bool = false;
    const DEFAULT: Option<Self::Type> = None;

    fn default_fn(&'a self) -> Option<impl Fn() -> Self::Type> {
        None::<fn() -> Self::Type>
    }
}

impl<'a> std::fmt::Debug for dyn SQLColumnInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SQLColumnInfo")
            .field("name", &self.name())
            .field("type", &self.r#type())
            .field("not_null", &self.is_not_null())
            .field("primary_key", &self.is_primary_key())
            .field("unique", &self.is_unique())
            .field("table", &self.table())
            .finish()
    }
}

/// A marker trait to ensure a type is a tuple of `SQLColumn`s.
pub trait SQLColumns<'a> {
    fn columns(&'a self) -> Box<[&'a dyn SQLColumnInfo]>;
}

pub trait SQLModel<'a, V: SQLParam> {
    fn columns(&self) -> crate::SQL<'a, V>;
    fn values(&self) -> crate::SQL<'a, V>;
}

/// Trait for models that support partial selection of fields
pub trait SQLPartial<'a, Value: SQLParam> {
    /// The type representing a partial model where all fields are optional
    /// for selective querying
    type Partial: ToSQL<'a, Value> + SQLModel<'a, Value> + Default + 'a;

    fn partial() -> Self::Partial {
        Default::default()
    }
}

pub trait SQLTable<'a, Value: SQLParam>: SQLTableInfo + Default + ToSQL<'a, Value> {
    /// The type representing a model for SELECT operations on this table.
    /// This would be generated by the table macro.
    type Select: ToSQL<'a, Value> + SQLModel<'a, Value> + SQLPartial<'a, Value> + Default + 'a;

    /// The type representing a model for INSERT operations on this table.
    /// This would be generated by the table macro.
    type Insert: ToSQL<'a, Value> + SQLModel<'a, Value> + Default + 'a;

    /// The type representing a model for UPDATE operations on this table.
    /// This would be generated by the table macro.
    type Update: ToSQL<'a, Value> + SQLModel<'a, Value> + Default + 'a;
    type Schema: SQLSchema<'a, SQLSchemaType>;
    type Columns: SQLColumns<'a>;

    const COUNT: usize;
    const COLUMNS: Self::Columns;
}

pub trait SQLTableInfo: Any {
    fn name(&self) -> &str;
    fn r#type(&self) -> SQLSchemaType;
}

impl<'a> std::fmt::Debug for dyn SQLTableInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SQLTableInfo")
            .field("name", &self.name())
            .field("type", &self.r#type())
            .finish()
    }
}

/// Marker trait for types that can be compared in SQL expressions.
pub trait SQLComparable<'a, V: SQLParam, Rhs> {}

pub trait SQLAlias {
    /// Gets the alias name for this table
    fn alias(&self) -> &'static str;
}

// ============================================================================
// SQLComparable Implementations
// ============================================================================
/// Column-to-Column comparison (most specific, type-safe)
/// Only allows comparisons between columns with the same underlying type
// impl<'a, V, L, R, T> SQLComparable<'a, V, R> for L
// where
//     V: SQLParam + 'a,
//     L: SQLColumn<'a, V, Type = T> + ToSQL<'a, V>,
//     R: SQLColumn<'a, V, Type = T> + ToSQL<'a, V>,
//     T: PartialEq, // Ensures the underlying types can be compared
// {
// }
/// Column-to-Value comparison (type-safe)
/// Only allows comparisons between a column and a value of the same type
// impl<'a, V, C, T> SQLComparable<'a, V, T> for C
// where
//     V: SQLParam + 'a,
//     C: SQLColumn<'a, V, Type = T> + ToSQL<'a, V>,
//     T: Into<V> + ToSQL<'a, V> + PartialEq,
// {
// }
/// Value-to-Value comparison (most general, permissive)
/// Allows any two values that can convert to SQL parameters
// impl<'a, V, L, R> SQLComparable<'a, V, R> for L
// where
//     V: SQLParam + 'a,
//     L: Into<V> + ToSQL<'a, V>,
//     R: Into<V> + ToSQL<'a, V>,
// {
// }
/// Blanket implementation for all compatible types
/// This covers all three cases:
/// 1. Column-to-Column (when both L and R are SQLColumn with same Type)
/// 2. Column-to-Value (when L is SQLColumn and R converts to same type)  
/// 3. Value-to-Value (when both convert to SQL values)
impl<'a, V, L, R> SQLComparable<'a, V, R> for L
where
    V: SQLParam + 'a,
    L: ToSQL<'a, V>,
    R: ToSQL<'a, V> + Into<V>,
{
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sql_param_implementations() {
        // Test that common types implement SQLParam
        fn assert_sql_param<T: SQLParam>(_: &T) {}

        assert_sql_param(&String::new());
        assert_sql_param(&"test");
        assert_sql_param(&42i32);
        assert_sql_param(&42i64);
        assert_sql_param(&true);
        assert_sql_param(&Some(42));
        assert_sql_param(&None::<i32>);
        assert_sql_param(&vec![1, 2, 3]);
    }

    #[test]
    fn test_option_sql_param() {
        fn accepts_sql_param<T: SQLParam>(_: T) {}

        accepts_sql_param(Some(42i32));
        accepts_sql_param(None::<String>);
        accepts_sql_param(Some("test".to_string()));
    }

    #[test]
    fn test_vec_sql_param() {
        fn accepts_sql_param<T: SQLParam>(_: T) {}

        accepts_sql_param(vec![1, 2, 3]);
        accepts_sql_param(vec!["a", "b"]);
        accepts_sql_param(Vec::<i32>::new());
    }
}

/// Marker trait indicating that a table `T` is part of a schema represented by the marker type `S`.
///
/// This trait is used as a bound on methods like `QueryBuilder::from` and `QueryBuilder::join`
/// to ensure that only tables declared within a specific `schema!` macro invocation can be used
/// with the resulting query builder.
///
/// ## Compile-Time Errors
///
/// If you encounter a compile-time error message like:
/// ```text
/// the trait bound `YourTable: querybuilder::core::schema_traits::IsInSchema<...some_marker_module::SchemaMarker>` is not satisfied
/// ```
/// **This almost always means that `YourTable` was not included in the list of tables when the corresponding `schema!` macro was called.**
///
/// For example:
/// ```compile_fail
/// # use querybuilder::prelude::*;
/// # use querybuilder::sqlite::query_builder::{QueryBuilder, SQLiteQueryBuilder};
/// # use procmacros::SQLiteTable;
/// # #[SQLiteTable(name = "users")] struct User { id: i32 };
/// # #[SQLiteTable(name = "posts")] struct Post { id: i32 };
/// // Schema only includes User
/// let qb = querybuilder::schema!([User]);
///
/// // This line will FAIL because Post is not in the schema:
/// let posts = qb.from::<Post>().select_all(); // <-- Error happens here
/// ```
///
/// To fix this, ensure that `YourTable` is listed within the `[...]` of the `schema!` macro call
/// that created the query builder instance you are trying to use.
///
/// Implementations of this trait are generated automatically by the `schema!` macro for each table
/// listed within it, associating those tables with the unique, generated schema marker type `S`.
pub trait IsInSchema<S> {}
