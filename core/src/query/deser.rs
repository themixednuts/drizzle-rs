//! Deserialization from JSON columns in query results.

use crate::error::DrizzleError;
use crate::prelude::*;
use crate::relation::RelationDef;

use super::row::QueryRow;
use super::store::RelEntry;

/// Deserializes a `RelEntry` chain from pre-parsed JSON values.
pub trait DeserializeStore: Sized {
    /// Reads from consecutive pre-parsed JSON Values (top-level row columns).
    fn from_values(values: &[serde_json::Value], col: &mut usize) -> Result<Self, DrizzleError>;

    /// Reads from a parent JSON object's named fields (nested relations).
    /// Each relation is extracted by its `RelationDef::NAME` key.
    fn from_parent_json(parent: &serde_json::Value) -> Result<Self, DrizzleError>;
}

impl DeserializeStore for () {
    #[inline]
    fn from_values(_values: &[serde_json::Value], _col: &mut usize) -> Result<Self, DrizzleError> {
        Ok(())
    }

    #[inline]
    fn from_parent_json(_parent: &serde_json::Value) -> Result<Self, DrizzleError> {
        Ok(())
    }
}

impl<Rel, Data, Rest> DeserializeStore for RelEntry<Rel, Data, Rest>
where
    Rel: RelationDef,
    Data: FromJsonColumn,
    Rest: DeserializeStore,
{
    fn from_values(values: &[serde_json::Value], col: &mut usize) -> Result<Self, DrizzleError> {
        let val = values.get(*col).ok_or_else(|| {
            DrizzleError::Other(format!("missing JSON column at index {}", *col).into())
        })?;
        *col += 1;
        let data = Data::from_value(val)?;
        let rest = Rest::from_values(values, col)?;
        Ok(RelEntry::new(data, rest))
    }

    fn from_parent_json(parent: &serde_json::Value) -> Result<Self, DrizzleError> {
        let nested_val = parent.get(Rel::NAME).unwrap_or(&serde_json::Value::Null);
        let data = Data::from_value(nested_val)?;
        let rest = Rest::from_parent_json(parent)?;
        Ok(RelEntry::new(data, rest))
    }
}

/// Parses a relation's wrapped data from a pre-parsed JSON Value.
///
/// Implemented for `Vec<T>` (Many), `Option<T>` (OptionalOne),
/// and `QueryRow<Base, Store>` (One).
pub trait FromJsonColumn: Sized {
    /// Converts a JSON value into this type.
    ///
    /// Receives the raw JSON column value from the query result.
    /// `Null` is valid for `Vec<T>` (empty) and `Option<T>` (None).
    fn from_value(val: &serde_json::Value) -> Result<Self, DrizzleError>;
}

// Vec<T>: parse JSON array (null â†’ empty vec for Many cardinality with no rows).
// SQLite's `json_group_array` returns `[null]` (not `[]`) when zero rows match,
// so null elements are skipped to produce the correct empty `Vec`.
impl<T: FromJsonValue> FromJsonColumn for Vec<T> {
    fn from_value(val: &serde_json::Value) -> Result<Self, DrizzleError> {
        match val {
            serde_json::Value::Null => Ok(Vec::new()),
            serde_json::Value::Array(arr) => arr
                .iter()
                .filter(|v| !v.is_null())
                .map(|v| T::from_json_value(v))
                .collect(),
            _ => Err(DrizzleError::Other("expected JSON array or null".into())),
        }
    }
}

// Option<T>: parse JSON object or null
impl<T: FromJsonValue> FromJsonColumn for Option<T> {
    fn from_value(val: &serde_json::Value) -> Result<Self, DrizzleError> {
        if val.is_null() {
            Ok(None)
        } else {
            Ok(Some(T::from_json_value(val)?))
        }
    }
}

// QueryRow<Base, Store>: parse JSON object (One cardinality)
impl<Base: FromJsonValue, Store: DeserializeStore> FromJsonColumn for QueryRow<Base, Store> {
    fn from_value(val: &serde_json::Value) -> Result<Self, DrizzleError> {
        if val.is_null() {
            return Err(DrizzleError::Other(
                "expected non-null relation (One cardinality)".into(),
            ));
        }
        Self::from_json_value(val)
    }
}

/// Parses a single value from a JSON object.
///
/// Generated by the table macro for each select model.
/// Reads fields by column name from a JSON object.
pub trait FromJsonValue: Sized {
    /// Deserializes this type from a JSON object value.
    ///
    /// The input `val` is a JSON object whose keys correspond to column names.
    fn from_json_value(val: &serde_json::Value) -> Result<Self, DrizzleError>;
}

// QueryRow<Base, Store>: deserialize base fields + nested relations from same JSON object.
impl<Base: FromJsonValue, Store: DeserializeStore> FromJsonValue for QueryRow<Base, Store> {
    fn from_json_value(val: &serde_json::Value) -> Result<Self, DrizzleError> {
        let base = Base::from_json_value(val)?;
        let store = Store::from_parent_json(val)?;
        Ok(QueryRow::new(base, store))
    }
}

/// Deserializes a single field from a `&serde_json::Value`.
#[inline]
pub fn deserialize_field<T: serde::de::DeserializeOwned>(
    val: &serde_json::Value,
    field_name: &str,
) -> Result<T, DrizzleError> {
    T::deserialize(val)
        .map_err(|e| DrizzleError::Other(format!("field '{field_name}': {e}").into()))
}
