//! Drizzle CLI - Migration tool for drizzle-rs
//!
//! This CLI provides commands for managing database migrations, compatible with
//! drizzle-kit's migration format.

mod commands;
mod config;
mod error;
mod schema;
mod snapshot;

use clap::{Parser, Subcommand, ValueEnum};
use colored::Colorize;
use drizzle_migrations::Dialect;

/// CLI-specific dialect enum that maps to drizzle_migrations::Dialect
#[derive(Clone, Copy, Debug, ValueEnum)]
pub enum CliDialect {
    Sqlite,
    Postgresql,
    Mysql,
}

impl From<CliDialect> for Dialect {
    fn from(d: CliDialect) -> Self {
        match d {
            CliDialect::Sqlite => Dialect::Sqlite,
            CliDialect::Postgresql => Dialect::Postgresql,
            CliDialect::Mysql => Dialect::Mysql,
        }
    }
}

impl From<Dialect> for CliDialect {
    fn from(d: Dialect) -> Self {
        match d {
            Dialect::Sqlite => CliDialect::Sqlite,
            Dialect::Postgresql => CliDialect::Postgresql,
            Dialect::Mysql => CliDialect::Mysql,
        }
    }
}

#[derive(Parser)]
#[command(
    name = "drizzle",
    about = "Drizzle CLI - Database migration tool for Rust",
    version,
    author,
    propagate_version = true
)]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    /// Path to drizzle.toml config file
    #[arg(short, long, global = true, env = "DRIZZLE_CONFIG")]
    config: Option<String>,
}

#[derive(Subcommand)]
enum Commands {
    /// Generate a new migration by diffing schema against last snapshot
    Generate {
        /// Path to schema JSON file (generated by build.rs or exported)
        #[arg(short, long)]
        schema: Option<String>,

        /// Output directory for migrations
        #[arg(short, long)]
        out: Option<String>,

        /// Database dialect: sqlite, postgresql, mysql
        #[arg(short, long, value_enum)]
        dialect: Option<CliDialect>,

        /// Custom migration name
        #[arg(short, long)]
        name: Option<String>,

        /// Create an empty migration for custom SQL
        #[arg(long, default_value = "false")]
        custom: bool,

        /// Prefix style: index (0000), timestamp, or none
        #[arg(long, default_value = "index")]
        prefix: String,

        /// Add statement breakpoints (use --breakpoints=false to disable)
        #[arg(long, default_value_t = true, action = clap::ArgAction::Set)]
        breakpoints: bool,
    },

    /// Check migration files for consistency
    Check {
        /// Output directory containing migrations
        #[arg(short, long)]
        out: Option<String>,

        /// Database dialect
        #[arg(short, long, value_enum)]
        dialect: Option<CliDialect>,
    },

    /// Drop a migration
    Drop {
        /// Output directory containing migrations
        #[arg(short, long)]
        out: Option<String>,
    },

    /// Initialize a new drizzle.toml configuration file
    Init {
        /// Database dialect: sqlite, postgresql, mysql
        #[arg(short, long, value_enum, default_value = "sqlite")]
        dialect: CliDialect,
    },

    /// Show the current schema status
    Status {
        /// Output directory containing migrations
        #[arg(short, long)]
        out: Option<String>,
    },

    /// Upgrade snapshots to the latest version
    Up {
        /// Output directory containing migrations
        #[arg(short, long)]
        out: Option<String>,

        /// Database dialect
        #[arg(short, long, value_enum)]
        dialect: Option<CliDialect>,
    },
}

fn main() {
    if let Err(e) = run() {
        eprintln!("{} {}", "error:".red().bold(), e);
        std::process::exit(1);
    }
}

fn run() -> anyhow::Result<()> {
    let cli = Cli::parse();

    // Try to load config
    let config = config::load_config(cli.config.as_deref())?;

    match cli.command {
        Commands::Generate {
            schema,
            out,
            dialect,
            name,
            custom,
            prefix,
            breakpoints,
        } => {
            let dialect = dialect
                .map(Dialect::from)
                .or_else(|| config.as_ref().map(|c| c.dialect))
                .unwrap_or(Dialect::Sqlite);

            let opts = commands::generate::GenerateOptions {
                schema_path: schema,
                out_dir: out
                    .or_else(|| config.as_ref().map(|c| c.out.to_string_lossy().to_string()))
                    .unwrap_or_else(|| "drizzle".to_string()),
                dialect,
                name,
                custom,
                prefix,
                breakpoints,
            };
            commands::generate::run(opts)?;
        }

        Commands::Check { out, dialect } => {
            let dialect = dialect
                .map(Dialect::from)
                .or_else(|| config.as_ref().map(|c| c.dialect))
                .unwrap_or(Dialect::Sqlite);

            let opts = commands::check::CheckOptions {
                out_dir: out
                    .or_else(|| config.as_ref().map(|c| c.out.to_string_lossy().to_string()))
                    .unwrap_or_else(|| "drizzle".to_string()),
                dialect,
            };
            commands::check::run(opts)?;
        }

        Commands::Drop { out } => {
            let opts = commands::drop::DropOptions {
                out_dir: out
                    .or_else(|| config.as_ref().map(|c| c.out.to_string_lossy().to_string()))
                    .unwrap_or_else(|| "drizzle".to_string()),
            };
            commands::drop::run(opts)?;
        }

        Commands::Init { dialect } => {
            commands::init::run(dialect.into())?;
        }

        Commands::Status { out } => {
            let out_dir = out
                .or_else(|| config.as_ref().map(|c| c.out.to_string_lossy().to_string()))
                .unwrap_or_else(|| "drizzle".to_string());
            commands::status::run(&out_dir)?;
        }

        Commands::Up { out, dialect } => {
            let dialect = dialect
                .map(Dialect::from)
                .or_else(|| config.as_ref().map(|c| c.dialect))
                .unwrap_or(Dialect::Sqlite);

            let opts = commands::up::UpOptions {
                out_dir: out
                    .or_else(|| config.as_ref().map(|c| c.out.to_string_lossy().to_string()))
                    .unwrap_or_else(|| "drizzle".to_string()),
                dialect,
            };
            commands::up::run(opts)?;
        }
    }

    Ok(())
}
