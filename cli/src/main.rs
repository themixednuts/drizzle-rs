//! Drizzle CLI - Migration tool for drizzle-rs
//!
//! This CLI provides commands for managing database migrations, compatible with
//! drizzle-kit's migration format.

mod commands;
mod config;
mod error;
mod schema;
mod snapshot;

use clap::{Parser, Subcommand};
use colored::Colorize;

#[derive(Parser)]
#[command(
    name = "drizzle",
    about = "Drizzle CLI - Database migration tool for Rust",
    version,
    author,
    propagate_version = true
)]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    /// Path to drizzle.toml config file
    #[arg(short, long, global = true, env = "DRIZZLE_CONFIG")]
    config: Option<String>,
}

#[derive(Subcommand)]
enum Commands {
    /// Generate a new migration by diffing schema against last snapshot
    Generate {
        /// Path to schema JSON file (generated by build.rs or exported)
        #[arg(short, long)]
        schema: Option<String>,

        /// Output directory for migrations
        #[arg(short, long)]
        out: Option<String>,

        /// Database dialect: sqlite, postgresql, mysql
        #[arg(short, long)]
        dialect: Option<String>,

        /// Custom migration name
        #[arg(short, long)]
        name: Option<String>,

        /// Create an empty migration for custom SQL
        #[arg(long, default_value = "false")]
        custom: bool,

        /// Prefix style: index (0000), timestamp, or none
        #[arg(long, default_value = "index")]
        prefix: String,

        /// Add statement breakpoints
        #[arg(long, default_value = "true")]
        breakpoints: bool,
    },

    /// Check migration files for consistency
    Check {
        /// Output directory containing migrations
        #[arg(short, long)]
        out: Option<String>,

        /// Database dialect
        #[arg(short, long)]
        dialect: Option<String>,
    },

    /// Drop a migration
    Drop {
        /// Output directory containing migrations
        #[arg(short, long)]
        out: Option<String>,
    },

    /// Initialize a new drizzle.toml configuration file
    Init {
        /// Database dialect: sqlite, postgresql, mysql
        #[arg(short, long, default_value = "sqlite")]
        dialect: String,
    },

    /// Show the current schema status
    Status {
        /// Output directory containing migrations
        #[arg(short, long)]
        out: Option<String>,
    },
}

fn main() {
    if let Err(e) = run() {
        eprintln!("{} {}", "error:".red().bold(), e);
        std::process::exit(1);
    }
}

fn run() -> anyhow::Result<()> {
    let cli = Cli::parse();

    // Try to load config
    let config = config::load_config(cli.config.as_deref())?;

    match cli.command {
        Commands::Generate {
            schema,
            out,
            dialect,
            name,
            custom,
            prefix,
            breakpoints,
        } => {
            let opts = commands::generate::GenerateOptions {
                schema_path: schema,
                out_dir: out
                    .or_else(|| config.as_ref().map(|c| c.out.to_string_lossy().to_string()))
                    .unwrap_or_else(|| "drizzle".to_string()),
                dialect: dialect
                    .or_else(|| config.as_ref().map(|c| c.dialect.to_string()))
                    .unwrap_or_else(|| "sqlite".to_string()),
                name,
                custom,
                prefix,
                breakpoints,
            };
            commands::generate::run(opts)?;
        }

        Commands::Check { out, dialect } => {
            let opts = commands::check::CheckOptions {
                out_dir: out
                    .or_else(|| config.as_ref().map(|c| c.out.to_string_lossy().to_string()))
                    .unwrap_or_else(|| "drizzle".to_string()),
                dialect: dialect
                    .or_else(|| config.as_ref().map(|c| c.dialect.to_string()))
                    .unwrap_or_else(|| "sqlite".to_string()),
            };
            commands::check::run(opts)?;
        }

        Commands::Drop { out } => {
            let opts = commands::drop::DropOptions {
                out_dir: out
                    .or_else(|| config.as_ref().map(|c| c.out.to_string_lossy().to_string()))
                    .unwrap_or_else(|| "drizzle".to_string()),
            };
            commands::drop::run(opts)?;
        }

        Commands::Init { dialect } => {
            commands::init::run(&dialect)?;
        }

        Commands::Status { out } => {
            let out_dir = out
                .or_else(|| config.as_ref().map(|c| c.out.to_string_lossy().to_string()))
                .unwrap_or_else(|| "drizzle".to_string());
            commands::status::run(&out_dir)?;
        }
    }

    Ok(())
}

