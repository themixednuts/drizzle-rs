//! PostgreSQL SQL generation tests
//!
//! These tests verify that the SQL generated by the PostgreSQL query builder
//! produces correct and properly formatted SQL statements with PostgreSQL-specific syntax.

#![cfg(feature = "postgres")]

use crate::common::pg::*;
use drizzle::prelude::*;
use drizzle::sql;
use drizzle_postgres::values::PostgresValue;

#[test]
fn test_simple_select_all_sql_generation() {
    let PgSimpleSchema { simple } = PgSimpleSchema::new();

    let query = drizzle::postgres::QueryBuilder::new::<()>()
        .select(())
        .from(simple);
    let sql = query.to_sql();

    println!("Simple select all SQL: {}", sql.sql());

    let sql_string = sql.sql();

    // Should contain SELECT and FROM clauses with quoted identifiers
    assert!(sql_string.starts_with("SELECT "));
    assert!(sql_string.contains(r#"FROM "pg_simple""#));

    // Check that both columns are included with qualified names
    assert!(
        sql_string.contains(r#""pg_simple"."id""#),
        "SQL should contain id column: {}",
        sql_string
    );
    assert!(
        sql_string.contains(r#""pg_simple"."name""#),
        "SQL should contain name column: {}",
        sql_string
    );
}

#[test]
fn test_complex_select_all_sql_generation() {
    let PgComplexSchema { complex, .. } = PgComplexSchema::new();

    let query = drizzle::postgres::QueryBuilder::new::<()>()
        .select(())
        .from(complex);
    let sql = query.to_sql();

    println!("Complex select all SQL: {}", sql.sql());

    let sql_string = sql.sql();
    assert!(sql_string.starts_with("SELECT "));
    assert!(sql_string.contains(r#"FROM "pg_complex""#));

    // Check that key columns are included
    let key_columns = vec![
        r#""pg_complex"."id""#,
        r#""pg_complex"."name""#,
        r#""pg_complex"."email""#,
    ];
    for col in key_columns {
        assert!(
            sql_string.contains(col),
            "SQL should contain {}: {}",
            col,
            sql_string
        );
    }
}

#[test]
fn test_select_all_with_where_clause() {
    let PgSimpleSchema { simple } = PgSimpleSchema::new();

    let query = drizzle::postgres::QueryBuilder::new::<()>()
        .select(())
        .from(simple)
        .r#where(eq(PgSimple::name, "test"));

    let sql = query.to_sql();
    println!("Select all with WHERE SQL: {}", sql.sql());

    let sql_string = sql.sql();

    // Should contain qualified columns in SELECT
    assert!(sql_string.contains(r#""pg_simple"."id""#));
    assert!(sql_string.contains(r#""pg_simple"."name""#));

    // Should contain FROM and WHERE clauses
    assert!(sql_string.contains(r#"FROM "pg_simple""#));
    assert!(sql_string.contains("WHERE"));

    // PostgreSQL uses $1, $2, etc. for parameters
    assert!(
        sql_string.contains("$1"),
        "Should use PostgreSQL numbered placeholders: {}",
        sql_string
    );

    // Parameters should include the where condition value
    let params = sql.params();
    assert!(
        !params.is_empty(),
        "Should have parameters for WHERE clause"
    );
}

#[test]
fn test_select_specific_columns_vs_select_all() {
    let PgSimpleSchema { simple } = PgSimpleSchema::new();

    let select_all_query = drizzle::postgres::QueryBuilder::new::<()>()
        .select(())
        .from(simple);
    let select_specific_query = drizzle::postgres::QueryBuilder::new::<()>()
        .select((simple.id, simple.name))
        .from(simple);

    let select_all_sql = select_all_query.to_sql().sql();
    let select_specific_sql = select_specific_query.to_sql().sql();

    println!("Select all SQL: {}", select_all_sql);
    println!("Select specific SQL: {}", select_specific_sql);

    // Both should contain the same columns
    assert!(select_all_sql.contains(r#""pg_simple"."id""#));
    assert!(select_all_sql.contains(r#""pg_simple"."name""#));
    assert!(select_specific_sql.contains(r#""pg_simple"."id""#));
    assert!(select_specific_sql.contains(r#""pg_simple"."name""#));

    // Both should have FROM clause
    assert!(select_all_sql.contains(r#"FROM "pg_simple""#));
    assert!(select_specific_sql.contains(r#"FROM "pg_simple""#));
}

#[test]
fn test_sql_macro_with_postgres_table() {
    let PgSimpleSchema { simple } = PgSimpleSchema::new();

    let id: i32 = 4;
    let query = sql!("SELECT * FROM {simple} WHERE {simple.id} = {id}");
    let sql_str = query.sql();
    let params = query.params();

    println!("SQL macro output: {}", sql_str);

    // Should use PostgreSQL $1 placeholder
    assert_eq!(
        sql_str,
        r#"SELECT * FROM "pg_simple" WHERE "pg_simple"."id" = $1"#
    );
    assert_eq!(params.len(), 1);
    assert_eq!(params[0], &PostgresValue::Integer(id));
}

#[test]
fn test_sql_printf_style() {
    let PgSimpleSchema { simple } = PgSimpleSchema::new();
    let id: i32 = 5;

    let query = sql!("SELECT * FROM {} WHERE {} = {}", simple, simple.id, id);
    let sql_str = query.sql();
    let params = query.params();

    println!("SQL printf-style output: {}", sql_str);

    // Should use PostgreSQL $1 placeholder
    assert_eq!(
        sql_str,
        r#"SELECT * FROM "pg_simple" WHERE "pg_simple"."id" = $1"#
    );
    assert_eq!(params.len(), 1);
    assert_eq!(params[0], &PostgresValue::Integer(id));
}

#[test]
fn test_order_by_sql_generation() {
    let PgSimpleSchema { simple } = PgSimpleSchema::new();

    let query = drizzle::postgres::QueryBuilder::new::<()>()
        .select((simple.id, simple.name))
        .from(simple)
        .order_by([OrderBy::asc(simple.name)])
        .limit(10);

    let sql = query.to_sql();
    let sql_string = sql.sql();

    println!("Order by SQL: {}", sql_string);

    assert!(sql_string.contains("ORDER BY"));
    assert!(sql_string.contains(r#""pg_simple"."name""#));
    assert!(sql_string.contains("ASC"));
    assert!(sql_string.contains("LIMIT"));
}

#[test]
fn test_order_by_desc_sql_generation() {
    let PgSimpleSchema { simple } = PgSimpleSchema::new();

    let query = drizzle::postgres::QueryBuilder::new::<()>()
        .select((simple.id, simple.name))
        .from(simple)
        .order_by([OrderBy::desc(simple.id)]);

    let sql = query.to_sql();
    let sql_string = sql.sql();

    println!("Order by DESC SQL: {}", sql_string);

    assert!(sql_string.contains("ORDER BY"));
    assert!(sql_string.contains("DESC"));
}

#[test]
fn test_limit_offset_sql_generation() {
    let PgSimpleSchema { simple } = PgSimpleSchema::new();

    let query = drizzle::postgres::QueryBuilder::new::<()>()
        .select((simple.id, simple.name))
        .from(simple)
        .limit(10)
        .offset(20);

    let sql = query.to_sql();
    let sql_string = sql.sql();

    println!("Limit offset SQL: {}", sql_string);

    assert!(sql_string.contains("LIMIT"));
    assert!(sql_string.contains("OFFSET"));
}

#[test]
fn test_multiple_where_conditions() {
    let PgComplexSchema { complex, .. } = PgComplexSchema::new();

    let query = drizzle::postgres::QueryBuilder::new::<()>()
        .select(())
        .from(complex)
        .r#where(and([eq(complex.active, true), gt(complex.age, 25)]));

    let sql = query.to_sql();
    let sql_string = sql.sql();

    println!("Multiple WHERE conditions SQL: {}", sql_string);

    assert!(sql_string.contains("WHERE"));
    assert!(sql_string.contains("AND"));
    assert!(sql_string.contains(r#""pg_complex"."active""#));
    assert!(sql_string.contains(r#""pg_complex"."age""#));
    // Should use numbered PostgreSQL placeholders
    assert!(sql_string.contains("$1"));
    assert!(sql_string.contains("$2"));
}

#[test]
fn test_or_condition_sql_generation() {
    let PgComplexSchema { complex, .. } = PgComplexSchema::new();

    let query = drizzle::postgres::QueryBuilder::new::<()>()
        .select(())
        .from(complex)
        .r#where(or([
            eq(complex.role, PgRole::Admin),
            eq(complex.role, PgRole::Moderator),
        ]));

    let sql = query.to_sql();
    let sql_string = sql.sql();

    println!("OR condition SQL: {}", sql_string);

    assert!(sql_string.contains("WHERE"));
    assert!(sql_string.contains("OR"));
}

#[test]
fn test_like_condition_sql_generation() {
    let PgSimpleSchema { simple } = PgSimpleSchema::new();

    let query = drizzle::postgres::QueryBuilder::new::<()>()
        .select(())
        .from(simple)
        .r#where(like(simple.name, "test%"));

    let sql = query.to_sql();
    let sql_string = sql.sql();

    println!("LIKE condition SQL: {}", sql_string);

    assert!(sql_string.contains("WHERE"));
    assert!(sql_string.contains("LIKE"));
    assert!(sql_string.contains("$1"));
}

#[test]
fn test_in_array_condition_sql_generation() {
    let PgSimpleSchema { simple } = PgSimpleSchema::new();

    let query = drizzle::postgres::QueryBuilder::new::<()>()
        .select(())
        .from(simple)
        .r#where(in_array(simple.name, ["Alice", "Bob", "Charlie"]));

    let sql = query.to_sql();
    let sql_string = sql.sql();

    println!("IN array condition SQL: {}", sql_string);

    assert!(sql_string.contains("WHERE"));
    assert!(sql_string.contains("IN"));
    assert!(sql_string.contains("("));
    assert!(sql_string.contains(")"));
    // Should have multiple PostgreSQL placeholders for the array values
    assert!(sql_string.contains("$1"));
    assert!(sql_string.contains("$2"));
    assert!(sql_string.contains("$3"));
}

#[test]
fn test_is_null_condition_sql_generation() {
    let PgComplexSchema { complex, .. } = PgComplexSchema::new();

    let query = drizzle::postgres::QueryBuilder::new::<()>()
        .select(())
        .from(complex)
        .r#where(is_null(complex.email));

    let sql = query.to_sql();
    let sql_string = sql.sql();

    println!("IS NULL condition SQL: {}", sql_string);

    assert!(sql_string.contains("WHERE"));
    assert!(sql_string.contains("IS NULL"));
}

#[test]
fn test_is_not_null_condition_sql_generation() {
    let PgComplexSchema { complex, .. } = PgComplexSchema::new();

    let query = drizzle::postgres::QueryBuilder::new::<()>()
        .select(())
        .from(complex)
        .r#where(is_not_null(complex.email));

    let sql = query.to_sql();
    let sql_string = sql.sql();

    println!("IS NOT NULL condition SQL: {}", sql_string);

    assert!(sql_string.contains("WHERE"));
    assert!(sql_string.contains("IS NOT NULL"));
}

#[test]
fn test_between_condition_sql_generation() {
    let PgComplexSchema { complex, .. } = PgComplexSchema::new();

    let query = drizzle::postgres::QueryBuilder::new::<()>()
        .select(())
        .from(complex)
        .r#where(between(complex.age, 18, 65));

    let sql = query.to_sql();
    let sql_string = sql.sql();

    println!("BETWEEN condition SQL: {}", sql_string);

    assert!(sql_string.contains("WHERE"));
    assert!(sql_string.contains("BETWEEN"));
    assert!(sql_string.contains("AND"));
    // PostgreSQL numbered placeholders
    assert!(sql_string.contains("$1"));
    assert!(sql_string.contains("$2"));
}
