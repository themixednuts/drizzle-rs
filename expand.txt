#![feature(prelude_import)]
#[macro_use]
extern crate std;
#[prelude_import]
use std::prelude::rust_2024::*;
mod schema {
    use drizzle::prelude::*;
    use uuid::Uuid;
    pub struct Users {
        pub id: UsersId,
        pub name: UsersName,
        pub age: UsersAge,
    }
    #[automatically_derived]
    impl ::core::default::Default for Users {
        #[inline]
        fn default() -> Users {
            Users {
                id: ::core::default::Default::default(),
                name: ::core::default::Default::default(),
                age: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Users {
        #[inline]
        fn clone(&self) -> Users {
            let _: ::core::clone::AssertParamIsClone<UsersId>;
            let _: ::core::clone::AssertParamIsClone<UsersName>;
            let _: ::core::clone::AssertParamIsClone<UsersAge>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Users {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Users {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Users",
                "id",
                &self.id,
                "name",
                &self.name,
                "age",
                &&self.age,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Users {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Users {
        #[inline]
        fn eq(&self, other: &Users) -> bool {
            self.id == other.id && self.name == other.name && self.age == other.age
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Users {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<UsersId>;
            let _: ::core::cmp::AssertParamIsEq<UsersName>;
            let _: ::core::cmp::AssertParamIsEq<UsersAge>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Users {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.id, state);
            ::core::hash::Hash::hash(&self.name, state);
            ::core::hash::Hash::hash(&self.age, state)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Users {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Users,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.id, &other.id) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(&self.name, &other.name) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.age, &other.age)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Users {
        #[inline]
        fn cmp(&self, other: &Users) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.id, &other.id) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.name, &other.name) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.age, &other.age)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    impl Users {
        /// Table metadata in drizzle-kit compatible JSON format.
        ///
        /// This constant contains the schema metadata for migrations,
        /// matching the format used by drizzle-kit snapshots.
        pub const __DRIZZLE_TABLE_META: &'static str = "{\"name\":\"users\",\"columns\":{\"name\":{\"name\":\"name\",\"type\":\"text\",\"primaryKey\":false,\"notNull\":true},\"id\":{\"name\":\"id\",\"type\":\"blob\",\"primaryKey\":true,\"notNull\":true},\"age\":{\"name\":\"age\",\"type\":\"integer\",\"primaryKey\":false,\"notNull\":true}},\"indexes\":{},\"foreignKeys\":{},\"compositePrimaryKeys\":{},\"uniqueConstraints\":{},\"checkConstraints\":{}}";
    }
    #[allow(non_upper_case_globals)]
    impl Users {
        pub const fn new() -> Self {
            Self {
                id: UsersId,
                name: UsersName,
                age: UsersAge,
            }
        }
        pub const id: UsersId = UsersId;
        pub const name: UsersName = UsersName;
        pub const age: UsersAge = UsersAge;
    }
    #[allow(non_camel_case_types)]
    pub struct UsersId;
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::fmt::Debug for UsersId {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "UsersId")
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UsersId {
        #[inline]
        fn clone(&self) -> UsersId {
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::marker::Copy for UsersId {}
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::default::Default for UsersId {
        #[inline]
        fn default() -> UsersId {
            UsersId {}
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialOrd for UsersId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UsersId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::Ord for UsersId {
        #[inline]
        fn cmp(&self, other: &UsersId) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::Eq for UsersId {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::marker::StructuralPartialEq for UsersId {}
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialEq for UsersId {
        #[inline]
        fn eq(&self, other: &UsersId) -> bool {
            true
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::hash::Hash for UsersId {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl UsersId {
        pub const fn new() -> UsersId {
            UsersId
        }
    }
    impl<'a> SQLSchema<'a, &'a str, SQLiteValue<'a>> for UsersId {
        const NAME: &'a str = "id";
        const TYPE: &'a str = "BLOB";
        const SQL: SQL<'a, SQLiteValue<'a>> = SQL::empty();
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            SQL::raw("id BLOB PRIMARY KEY NOT NULL")
        }
    }
    impl SQLColumnInfo for UsersId {
        fn name(&self) -> &str {
            <Self as SQLSchema<'_, &'static str, SQLiteValue<'_>>>::NAME
        }
        fn r#type(&self) -> &str {
            <Self as SQLSchema<'_, &'static str, SQLiteValue<'_>>>::TYPE
        }
        fn is_primary_key(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::PRIMARY_KEY
        }
        fn is_not_null(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::NOT_NULL
        }
        fn is_unique(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::UNIQUE
        }
        fn has_default(&self) -> bool {
            true
        }
        fn table(&self) -> &dyn SQLTableInfo {
            static TABLE: Users = Users::new();
            &TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLColumnInfo> {
            None
        }
    }
    impl SQLiteColumnInfo for UsersId {
        fn is_autoincrement(&self) -> bool {
            <Self as SQLiteColumn<'_>>::AUTOINCREMENT
        }
        fn table(&self) -> &dyn SQLiteTableInfo {
            static TABLE: Users = Users::new();
            &TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLiteColumnInfo> {
            None
        }
    }
    impl<'a> SQLColumn<'a, SQLiteValue<'a>> for UsersId {
        type Table = Users;
        type TableType = SQLiteSchemaType;
        type Type = Uuid;
        const PRIMARY_KEY: bool = true;
        const NOT_NULL: bool = true;
        const UNIQUE: bool = false;
        const DEFAULT: Option<Self::Type> = None;
        fn default_fn(&'a self) -> Option<impl Fn() -> Self::Type> {
            Some(Uuid::new_v4)
        }
    }
    impl<'a> SQLiteColumn<'a> for UsersId {
        const AUTOINCREMENT: bool = false;
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for UsersId {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            static INSTANCE: UsersId = UsersId;
            SQL::column(&INSTANCE)
        }
    }
    impl<'a> ::std::convert::Into<SQLiteValue<'a>> for UsersId {
        fn into(self) -> SQLiteValue<'a> {
            SQLiteValue::Text(::std::borrow::Cow::Borrowed("id"))
        }
    }
    #[allow(non_camel_case_types)]
    pub struct UsersName;
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::fmt::Debug for UsersName {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "UsersName")
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UsersName {
        #[inline]
        fn clone(&self) -> UsersName {
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::marker::Copy for UsersName {}
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::default::Default for UsersName {
        #[inline]
        fn default() -> UsersName {
            UsersName {}
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialOrd for UsersName {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UsersName,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::Ord for UsersName {
        #[inline]
        fn cmp(&self, other: &UsersName) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::Eq for UsersName {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::marker::StructuralPartialEq for UsersName {}
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialEq for UsersName {
        #[inline]
        fn eq(&self, other: &UsersName) -> bool {
            true
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::hash::Hash for UsersName {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl UsersName {
        pub const fn new() -> UsersName {
            UsersName
        }
    }
    impl<'a> SQLSchema<'a, &'a str, SQLiteValue<'a>> for UsersName {
        const NAME: &'a str = "name";
        const TYPE: &'a str = "TEXT";
        const SQL: SQL<'a, SQLiteValue<'a>> = SQL::empty();
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            SQL::raw("name TEXT NOT NULL")
        }
    }
    impl SQLColumnInfo for UsersName {
        fn name(&self) -> &str {
            <Self as SQLSchema<'_, &'static str, SQLiteValue<'_>>>::NAME
        }
        fn r#type(&self) -> &str {
            <Self as SQLSchema<'_, &'static str, SQLiteValue<'_>>>::TYPE
        }
        fn is_primary_key(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::PRIMARY_KEY
        }
        fn is_not_null(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::NOT_NULL
        }
        fn is_unique(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::UNIQUE
        }
        fn has_default(&self) -> bool {
            false
        }
        fn table(&self) -> &dyn SQLTableInfo {
            static TABLE: Users = Users::new();
            &TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLColumnInfo> {
            None
        }
    }
    impl SQLiteColumnInfo for UsersName {
        fn is_autoincrement(&self) -> bool {
            <Self as SQLiteColumn<'_>>::AUTOINCREMENT
        }
        fn table(&self) -> &dyn SQLiteTableInfo {
            static TABLE: Users = Users::new();
            &TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLiteColumnInfo> {
            None
        }
    }
    impl<'a> SQLColumn<'a, SQLiteValue<'a>> for UsersName {
        type Table = Users;
        type TableType = SQLiteSchemaType;
        type Type = String;
        const PRIMARY_KEY: bool = false;
        const NOT_NULL: bool = true;
        const UNIQUE: bool = false;
        const DEFAULT: Option<Self::Type> = None;
        fn default_fn(&'a self) -> Option<impl Fn() -> Self::Type> {
            None::<fn() -> Self::Type>
        }
    }
    impl<'a> SQLiteColumn<'a> for UsersName {
        const AUTOINCREMENT: bool = false;
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for UsersName {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            static INSTANCE: UsersName = UsersName;
            SQL::column(&INSTANCE)
        }
    }
    impl<'a> ::std::convert::Into<SQLiteValue<'a>> for UsersName {
        fn into(self) -> SQLiteValue<'a> {
            SQLiteValue::Text(::std::borrow::Cow::Borrowed("name"))
        }
    }
    #[allow(non_camel_case_types)]
    pub struct UsersAge;
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::fmt::Debug for UsersAge {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "UsersAge")
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UsersAge {
        #[inline]
        fn clone(&self) -> UsersAge {
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::marker::Copy for UsersAge {}
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::default::Default for UsersAge {
        #[inline]
        fn default() -> UsersAge {
            UsersAge {}
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialOrd for UsersAge {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UsersAge,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::Ord for UsersAge {
        #[inline]
        fn cmp(&self, other: &UsersAge) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::Eq for UsersAge {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::marker::StructuralPartialEq for UsersAge {}
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialEq for UsersAge {
        #[inline]
        fn eq(&self, other: &UsersAge) -> bool {
            true
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::hash::Hash for UsersAge {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl UsersAge {
        pub const fn new() -> UsersAge {
            UsersAge
        }
    }
    impl<'a> SQLSchema<'a, &'a str, SQLiteValue<'a>> for UsersAge {
        const NAME: &'a str = "age";
        const TYPE: &'a str = "INTEGER";
        const SQL: SQL<'a, SQLiteValue<'a>> = SQL::empty();
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            SQL::raw("age INTEGER NOT NULL")
        }
    }
    impl SQLColumnInfo for UsersAge {
        fn name(&self) -> &str {
            <Self as SQLSchema<'_, &'static str, SQLiteValue<'_>>>::NAME
        }
        fn r#type(&self) -> &str {
            <Self as SQLSchema<'_, &'static str, SQLiteValue<'_>>>::TYPE
        }
        fn is_primary_key(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::PRIMARY_KEY
        }
        fn is_not_null(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::NOT_NULL
        }
        fn is_unique(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::UNIQUE
        }
        fn has_default(&self) -> bool {
            false
        }
        fn table(&self) -> &dyn SQLTableInfo {
            static TABLE: Users = Users::new();
            &TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLColumnInfo> {
            None
        }
    }
    impl SQLiteColumnInfo for UsersAge {
        fn is_autoincrement(&self) -> bool {
            <Self as SQLiteColumn<'_>>::AUTOINCREMENT
        }
        fn table(&self) -> &dyn SQLiteTableInfo {
            static TABLE: Users = Users::new();
            &TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLiteColumnInfo> {
            None
        }
    }
    impl<'a> SQLColumn<'a, SQLiteValue<'a>> for UsersAge {
        type Table = Users;
        type TableType = SQLiteSchemaType;
        type Type = u64;
        const PRIMARY_KEY: bool = false;
        const NOT_NULL: bool = true;
        const UNIQUE: bool = false;
        const DEFAULT: Option<Self::Type> = None;
        fn default_fn(&'a self) -> Option<impl Fn() -> Self::Type> {
            None::<fn() -> Self::Type>
        }
    }
    impl<'a> SQLiteColumn<'a> for UsersAge {
        const AUTOINCREMENT: bool = false;
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for UsersAge {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            static INSTANCE: UsersAge = UsersAge;
            SQL::column(&INSTANCE)
        }
    }
    impl<'a> ::std::convert::Into<SQLiteValue<'a>> for UsersAge {
        fn into(self) -> SQLiteValue<'a> {
            SQLiteValue::Text(::std::borrow::Cow::Borrowed("age"))
        }
    }
    impl<'a> SQLSchema<'a, SQLiteSchemaType, SQLiteValue<'a>> for Users {
        const NAME: &'a str = "users";
        const TYPE: SQLiteSchemaType = {
            #[allow(non_upper_case_globals)]
            static TABLE_INSTANCE: Users = Users::new();
            SQLiteSchemaType::Table(&TABLE_INSTANCE)
        };
        const SQL: SQL<'a, SQLiteValue<'a>> = SQL::raw_const(
            "CREATE TABLE \"users\" (id BLOB PRIMARY KEY NOT NULL, name TEXT NOT NULL, age INTEGER NOT NULL);",
        );
    }
    impl<'a> SQLTable<'a, SQLiteSchemaType, SQLiteValue<'a>> for Users {
        type Select = SelectUsers;
        type Insert<T> = InsertUsers<'a, T>;
        type Update = UpdateUsers;
        type Aliased = AliasedUsers;
        fn alias(name: &'static str) -> Self::Aliased {
            AliasedUsers::new(name)
        }
    }
    impl SQLTableInfo for Users {
        fn name(&self) -> &str {
            <Self as SQLSchema<'_, SQLiteSchemaType, SQLiteValue<'_>>>::NAME
        }
        fn columns(&self) -> &'static [&'static dyn SQLColumnInfo] {
            #[allow(non_upper_case_globals)]
            static UsersId: UsersId = UsersId::new();
            #[allow(non_upper_case_globals)]
            static UsersName: UsersName = UsersName::new();
            #[allow(non_upper_case_globals)]
            static UsersAge: UsersAge = UsersAge::new();
            #[allow(non_upper_case_globals)]
            static COLUMNS: [&'static dyn SQLColumnInfo; 3usize] = [
                &UsersId,
                &UsersName,
                &UsersAge,
            ];
            &COLUMNS
        }
        fn dependencies(&self) -> Box<[&'static dyn SQLTableInfo]> {
            SQLTableInfo::columns(self)
                .iter()
                .filter_map(|col| SQLColumnInfo::foreign_key(*col))
                .map(|fk_col| SQLColumnInfo::table(fk_col))
                .collect()
        }
    }
    impl SQLiteTableInfo for Users {
        fn r#type(&self) -> &SQLiteSchemaType {
            &<Self as SQLSchema<'_, SQLiteSchemaType, SQLiteValue<'_>>>::TYPE
        }
        fn strict(&self) -> bool {
            false
        }
        fn without_rowid(&self) -> bool {
            false
        }
        fn sqlite_columns(&self) -> &'static [&'static dyn SQLiteColumnInfo] {
            #[allow(non_upper_case_globals)]
            static UsersId: UsersId = UsersId::new();
            #[allow(non_upper_case_globals)]
            static UsersName: UsersName = UsersName::new();
            #[allow(non_upper_case_globals)]
            static UsersAge: UsersAge = UsersAge::new();
            #[allow(non_upper_case_globals)]
            static SQLITE_COLUMNS: [&'static dyn SQLiteColumnInfo; 3usize] = [
                &UsersId,
                &UsersName,
                &UsersAge,
            ];
            &SQLITE_COLUMNS
        }
        fn sqlite_dependencies(&self) -> Box<[&'static dyn SQLiteTableInfo]> {
            SQLiteTableInfo::sqlite_columns(self)
                .iter()
                .filter_map(|col| SQLiteColumnInfo::foreign_key(*col))
                .map(|fk_col| SQLiteColumnInfo::table(fk_col))
                .collect()
        }
    }
    impl<'a> SQLiteTable<'a> for Users {
        const WITHOUT_ROWID: bool = false;
        const STRICT: bool = false;
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for Users {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            static INSTANCE: Users = Users::new();
            SQL::table(&INSTANCE)
        }
    }
    pub struct SelectUsers {
        pub id: Uuid,
        pub name: String,
        pub age: u64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SelectUsers {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "SelectUsers",
                "id",
                &self.id,
                "name",
                &self.name,
                "age",
                &&self.age,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SelectUsers {
        #[inline]
        fn clone(&self) -> SelectUsers {
            SelectUsers {
                id: ::core::clone::Clone::clone(&self.id),
                name: ::core::clone::Clone::clone(&self.name),
                age: ::core::clone::Clone::clone(&self.age),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SelectUsers {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SelectUsers {
        #[inline]
        fn eq(&self, other: &SelectUsers) -> bool {
            self.age == other.age && self.id == other.id && self.name == other.name
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for SelectUsers {
        #[inline]
        fn default() -> SelectUsers {
            SelectUsers {
                id: ::core::default::Default::default(),
                name: ::core::default::Default::default(),
                age: ::core::default::Default::default(),
            }
        }
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for SelectUsers {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            ::core::panicking::panic("not implemented")
        }
    }
    pub struct PartialSelectUsers {
        pub id: Option<Uuid>,
        pub name: Option<String>,
        pub age: Option<u64>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PartialSelectUsers {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "PartialSelectUsers",
                "id",
                &self.id,
                "name",
                &self.name,
                "age",
                &&self.age,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PartialSelectUsers {
        #[inline]
        fn clone(&self) -> PartialSelectUsers {
            PartialSelectUsers {
                id: ::core::clone::Clone::clone(&self.id),
                name: ::core::clone::Clone::clone(&self.name),
                age: ::core::clone::Clone::clone(&self.age),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PartialSelectUsers {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PartialSelectUsers {
        #[inline]
        fn eq(&self, other: &PartialSelectUsers) -> bool {
            self.id == other.id && self.name == other.name && self.age == other.age
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for PartialSelectUsers {
        #[inline]
        fn default() -> PartialSelectUsers {
            PartialSelectUsers {
                id: ::core::default::Default::default(),
                name: ::core::default::Default::default(),
                age: ::core::default::Default::default(),
            }
        }
    }
    impl PartialSelectUsers {
        pub fn with_id<T: Into<::uuid::Uuid>>(mut self, value: T) -> Self {
            let value = value.into();
            self.id = Some(value);
            self
        }
        pub fn with_name<T: Into<::std::string::String>>(mut self, value: T) -> Self {
            let value = value.into();
            self.name = Some(value);
            self
        }
        pub fn with_age(mut self, value: u64) -> Self {
            self.age = Some(value);
            self
        }
    }
    impl<'a> SQLPartial<'a, SQLiteValue<'a>> for SelectUsers {
        type Partial = PartialSelectUsers;
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for PartialSelectUsers {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            ::core::panicking::panic("not implemented")
        }
    }
    pub struct UsersIdSet;
    pub struct UsersIdNotSet;
    pub struct UsersNameSet;
    pub struct UsersNameNotSet;
    pub struct UsersAgeSet;
    pub struct UsersAgeNotSet;
    pub struct InsertUsers<'a, T = (UsersIdNotSet, UsersNameNotSet, UsersAgeNotSet)> {
        id: SQLiteInsertValue<'a, SQLiteValue<'a>, ::uuid::Uuid>,
        name: SQLiteInsertValue<'a, SQLiteValue<'a>, ::std::string::String>,
        age: SQLiteInsertValue<'a, SQLiteValue<'a>, u64>,
        _pattern: ::std::marker::PhantomData<T>,
    }
    #[automatically_derived]
    impl<'a, T: ::core::fmt::Debug> ::core::fmt::Debug for InsertUsers<'a, T> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "InsertUsers",
                "id",
                &self.id,
                "name",
                &self.name,
                "age",
                &self.age,
                "_pattern",
                &&self._pattern,
            )
        }
    }
    #[automatically_derived]
    impl<'a, T: ::core::clone::Clone> ::core::clone::Clone for InsertUsers<'a, T> {
        #[inline]
        fn clone(&self) -> InsertUsers<'a, T> {
            InsertUsers {
                id: ::core::clone::Clone::clone(&self.id),
                name: ::core::clone::Clone::clone(&self.name),
                age: ::core::clone::Clone::clone(&self.age),
                _pattern: ::core::clone::Clone::clone(&self._pattern),
            }
        }
    }
    impl<'a, T> Default for InsertUsers<'a, T> {
        fn default() -> Self {
            Self {
                id: ((Uuid::new_v4)()).into(),
                name: SQLiteInsertValue::Omit,
                age: SQLiteInsertValue::Omit,
                _pattern: ::std::marker::PhantomData,
            }
        }
    }
    impl<'a> InsertUsers<'a, (UsersIdNotSet, UsersNameNotSet, UsersAgeNotSet)> {
        pub fn new(
            name: impl Into<
                SQLiteInsertValue<'a, SQLiteValue<'a>, ::std::string::String>,
            >,
            age: impl Into<SQLiteInsertValue<'a, SQLiteValue<'a>, u64>>,
        ) -> InsertUsers<'a, (UsersIdNotSet, UsersNameSet, UsersAgeSet)> {
            InsertUsers {
                name: name.into(),
                age: age.into(),
                ..Default::default()
            }
        }
    }
    impl<'a, T> InsertUsers<'a, T> {
        /// Converts this insert model to an owned version with 'static lifetime
        pub fn into_owned(self) -> InsertUsers<'static, T> {
            InsertUsers {
                id: self.id.into_owned(),
                name: self.name.into_owned(),
                age: self.age.into_owned(),
                _pattern: ::std::marker::PhantomData,
            }
        }
    }
    impl<
        'a,
        UsersId,
        UsersName,
        UsersAge,
    > InsertUsers<'a, (UsersId, UsersName, UsersAge)> {
        pub fn with_id<V>(
            self,
            value: V,
        ) -> InsertUsers<'a, (UsersIdSet, UsersName, UsersAge)>
        where
            V: Into<SQLiteInsertValue<'a, SQLiteValue<'a>, ::uuid::Uuid>>,
        {
            InsertUsers {
                id: value.into(),
                name: self.name,
                age: self.age,
                _pattern: ::std::marker::PhantomData,
            }
        }
    }
    impl<
        'a,
        UsersId,
        UsersName,
        UsersAge,
    > InsertUsers<'a, (UsersId, UsersName, UsersAge)> {
        pub fn with_name<V>(
            self,
            value: V,
        ) -> InsertUsers<'a, (UsersId, UsersNameSet, UsersAge)>
        where
            V: Into<SQLiteInsertValue<'a, SQLiteValue<'a>, ::std::string::String>>,
        {
            InsertUsers {
                id: self.id,
                name: value.into(),
                age: self.age,
                _pattern: ::std::marker::PhantomData,
            }
        }
    }
    impl<
        'a,
        UsersId,
        UsersName,
        UsersAge,
    > InsertUsers<'a, (UsersId, UsersName, UsersAge)> {
        pub fn with_age<V>(
            self,
            value: V,
        ) -> InsertUsers<'a, (UsersId, UsersName, UsersAgeSet)>
        where
            V: Into<SQLiteInsertValue<'a, SQLiteValue<'a>, u64>>,
        {
            InsertUsers {
                id: self.id,
                name: self.name,
                age: value.into(),
                _pattern: ::std::marker::PhantomData,
            }
        }
    }
    impl<'a, T> ToSQL<'a, SQLiteValue<'a>> for InsertUsers<'a, T> {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            SQLModel::values(self)
        }
    }
    impl<'a, T> SQLModel<'a, SQLiteValue<'a>> for InsertUsers<'a, T> {
        type Columns = Box<[&'static dyn SQLColumnInfo]>;
        fn columns(&self) -> Self::Columns {
            static TABLE: Users = Users::new();
            let all_columns = SQLTableInfo::columns(&TABLE);
            let mut result_columns = Vec::new();
            match &self.id {
                SQLiteInsertValue::Omit => {}
                _ => {
                    result_columns.push(all_columns[0usize]);
                }
            }
            match &self.name {
                SQLiteInsertValue::Omit => {}
                _ => {
                    result_columns.push(all_columns[1usize]);
                }
            }
            match &self.age {
                SQLiteInsertValue::Omit => {}
                _ => {
                    result_columns.push(all_columns[2usize]);
                }
            }
            result_columns.into_boxed_slice()
        }
        fn values(&self) -> SQL<'a, SQLiteValue<'a>> {
            let mut sql_parts = Vec::new();
            match &self.id {
                SQLiteInsertValue::Omit => {}
                SQLiteInsertValue::Null => {
                    sql_parts.push(SQL::param(SQLiteValue::Null));
                }
                SQLiteInsertValue::Value(wrapper) => {
                    sql_parts.push(wrapper.value.clone());
                }
            }
            match &self.name {
                SQLiteInsertValue::Omit => {}
                SQLiteInsertValue::Null => {
                    sql_parts.push(SQL::param(SQLiteValue::Null));
                }
                SQLiteInsertValue::Value(wrapper) => {
                    sql_parts.push(wrapper.value.clone());
                }
            }
            match &self.age {
                SQLiteInsertValue::Omit => {}
                SQLiteInsertValue::Null => {
                    sql_parts.push(SQL::param(SQLiteValue::Null));
                }
                SQLiteInsertValue::Value(wrapper) => {
                    sql_parts.push(wrapper.value.clone());
                }
            }
            SQL::join(sql_parts, Token::COMMA)
        }
    }
    pub struct UpdateUsers {
        pub id: ::std::option::Option<Uuid>,
        pub name: ::std::option::Option<String>,
        pub age: ::std::option::Option<u64>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UpdateUsers {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "UpdateUsers",
                "id",
                &self.id,
                "name",
                &self.name,
                "age",
                &&self.age,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UpdateUsers {
        #[inline]
        fn clone(&self) -> UpdateUsers {
            UpdateUsers {
                id: ::core::clone::Clone::clone(&self.id),
                name: ::core::clone::Clone::clone(&self.name),
                age: ::core::clone::Clone::clone(&self.age),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UpdateUsers {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UpdateUsers {
        #[inline]
        fn eq(&self, other: &UpdateUsers) -> bool {
            self.id == other.id && self.name == other.name && self.age == other.age
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for UpdateUsers {
        #[inline]
        fn default() -> UpdateUsers {
            UpdateUsers {
                id: ::core::default::Default::default(),
                name: ::core::default::Default::default(),
                age: ::core::default::Default::default(),
            }
        }
    }
    impl UpdateUsers {
        pub fn with_id<T: Into<::uuid::Uuid>>(mut self, value: T) -> Self {
            let value = value.into();
            self.id = Some(value);
            self
        }
        pub fn with_name<T: Into<::std::string::String>>(mut self, value: T) -> Self {
            let value = value.into();
            self.name = Some(value);
            self
        }
        pub fn with_age(mut self, value: u64) -> Self {
            self.age = Some(value);
            self
        }
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for UpdateUsers {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            let mut assignments = Vec::new();
            if let Some(val) = &self.id {
                assignments
                    .push((
                        "id",
                        SQLiteValue::Blob(
                            ::std::borrow::Cow::Owned(val.as_bytes().to_vec()),
                        ),
                    ));
            }
            if let Some(val) = &self.name {
                assignments
                    .push(("name", val.clone().try_into().unwrap_or(SQLiteValue::Null)));
            }
            if let Some(val) = &self.age {
                assignments
                    .push(("age", val.clone().try_into().unwrap_or(SQLiteValue::Null)));
            }
            SQL::assignments(assignments)
        }
    }
    impl<'a> SQLModel<'a, SQLiteValue<'a>> for SelectUsers {
        type Columns = &'static [&'static dyn SQLColumnInfo];
        fn columns(&self) -> Self::Columns {
            static INSTANCE: Users = Users::new();
            <Users as SQLTableInfo>::columns(&INSTANCE)
        }
        fn values(&self) -> SQL<'a, SQLiteValue<'a>> {
            SQL::empty()
        }
    }
    impl<'a> SQLModel<'a, SQLiteValue<'a>> for UpdateUsers {
        type Columns = &'static [&'static dyn SQLColumnInfo];
        fn columns(&self) -> Self::Columns {
            static INSTANCE: Users = Users::new();
            <Users as SQLTableInfo>::columns(&INSTANCE)
        }
        fn values(&self) -> SQL<'a, SQLiteValue<'a>> {
            let mut values = Vec::new();
            if let Some(val) = &self.id {
                values.push(val.clone().try_into().unwrap_or(SQLiteValue::Null));
            }
            if let Some(val) = &self.name {
                values.push(val.clone().try_into().unwrap_or(SQLiteValue::Null));
            }
            if let Some(val) = &self.age {
                values.push(val.clone().try_into().unwrap_or(SQLiteValue::Null));
            }
            SQL::param_list(values)
        }
    }
    impl<'a> SQLModel<'a, SQLiteValue<'a>> for PartialSelectUsers {
        type Columns = &'static [&'static dyn SQLColumnInfo];
        fn columns(&self) -> Self::Columns {
            static INSTANCE: Users = Users::new();
            <Users as SQLTableInfo>::columns(&INSTANCE)
        }
        fn values(&self) -> SQL<'a, SQLiteValue<'a>> {
            SQL::empty()
        }
    }
    #[allow(non_upper_case_globals, dead_code)]
    pub struct AliasedUsersId {
        alias: &'static str,
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::fmt::Debug for AliasedUsersId {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "AliasedUsersId",
                "alias",
                &&self.alias,
            )
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::clone::Clone for AliasedUsersId {
        #[inline]
        fn clone(&self) -> AliasedUsersId {
            let _: ::core::clone::AssertParamIsClone<&'static str>;
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::Copy for AliasedUsersId {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::default::Default for AliasedUsersId {
        #[inline]
        fn default() -> AliasedUsersId {
            AliasedUsersId {
                alias: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialOrd for AliasedUsersId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AliasedUsersId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.alias, &other.alias)
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Ord for AliasedUsersId {
        #[inline]
        fn cmp(&self, other: &AliasedUsersId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.alias, &other.alias)
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Eq for AliasedUsersId {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'static str>;
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::StructuralPartialEq for AliasedUsersId {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialEq for AliasedUsersId {
        #[inline]
        fn eq(&self, other: &AliasedUsersId) -> bool {
            self.alias == other.alias
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::hash::Hash for AliasedUsersId {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.alias, state)
        }
    }
    impl AliasedUsersId {
        pub const fn new(alias: &'static str) -> Self {
            Self { alias }
        }
    }
    impl SQLColumnInfo for AliasedUsersId {
        fn name(&self) -> &str {
            static ORIGINAL_FIELD: UsersId = UsersId::new();
            <UsersId as SQLColumnInfo>::name(&ORIGINAL_FIELD)
        }
        fn r#type(&self) -> &str {
            static ORIGINAL_FIELD: UsersId = UsersId::new();
            <UsersId as SQLColumnInfo>::r#type(&ORIGINAL_FIELD)
        }
        fn is_primary_key(&self) -> bool {
            static ORIGINAL_FIELD: UsersId = UsersId::new();
            <UsersId as SQLColumnInfo>::is_primary_key(&ORIGINAL_FIELD)
        }
        fn is_not_null(&self) -> bool {
            static ORIGINAL_FIELD: UsersId = UsersId::new();
            <UsersId as SQLColumnInfo>::is_not_null(&ORIGINAL_FIELD)
        }
        fn is_unique(&self) -> bool {
            static ORIGINAL_FIELD: UsersId = UsersId::new();
            <UsersId as SQLColumnInfo>::is_unique(&ORIGINAL_FIELD)
        }
        fn has_default(&self) -> bool {
            static ORIGINAL_FIELD: UsersId = UsersId::new();
            <UsersId as SQLColumnInfo>::has_default(&ORIGINAL_FIELD)
        }
        fn table(&self) -> &dyn SQLTableInfo {
            static ORIGINAL_TABLE: Users = Users::new();
            &ORIGINAL_TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLColumnInfo> {
            static ORIGINAL_FIELD: UsersId = UsersId::new();
            <UsersId as SQLColumnInfo>::foreign_key(&ORIGINAL_FIELD)
        }
    }
    impl SQLiteColumnInfo for AliasedUsersId {
        fn is_autoincrement(&self) -> bool {
            static ORIGINAL_FIELD: UsersId = UsersId::new();
            <UsersId as SQLiteColumnInfo>::is_autoincrement(&ORIGINAL_FIELD)
        }
        fn table(&self) -> &dyn SQLiteTableInfo {
            static ORIGINAL_FIELD: UsersId = UsersId::new();
            <UsersId as SQLiteColumnInfo>::table(&ORIGINAL_FIELD)
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLiteColumnInfo> {
            static ORIGINAL_FIELD: UsersId = UsersId::new();
            <UsersId as SQLiteColumnInfo>::foreign_key(&ORIGINAL_FIELD)
        }
    }
    impl<'a> SQLColumn<'a, SQLiteValue<'a>> for AliasedUsersId {
        type Table = AliasedUsers;
        type TableType = <UsersId as SQLColumn<'a, SQLiteValue<'a>>>::TableType;
        type Type = <UsersId as SQLColumn<'a, SQLiteValue<'a>>>::Type;
        const PRIMARY_KEY: bool = <UsersId as SQLColumn<
            'a,
            SQLiteValue<'a>,
        >>::PRIMARY_KEY;
        const NOT_NULL: bool = <UsersId as SQLColumn<'a, SQLiteValue<'a>>>::NOT_NULL;
        const UNIQUE: bool = <UsersId as SQLColumn<'a, SQLiteValue<'a>>>::UNIQUE;
        const DEFAULT: Option<Self::Type> = <UsersId as SQLColumn<
            'a,
            SQLiteValue<'a>,
        >>::DEFAULT;
        fn default_fn(&'a self) -> Option<impl Fn() -> Self::Type> {
            static ORIGINAL_FIELD: UsersId = UsersId::new();
            ORIGINAL_FIELD.default_fn()
        }
    }
    impl<'a> SQLiteColumn<'a> for AliasedUsersId {
        const AUTOINCREMENT: bool = <UsersId as SQLiteColumn<'a>>::AUTOINCREMENT;
    }
    impl<'a> SQLSchema<'a, &'a str, SQLiteValue<'a>> for AliasedUsersId {
        const NAME: &'a str = <UsersId as SQLSchema<'a, &'a str, SQLiteValue<'a>>>::NAME;
        const TYPE: &'a str = <UsersId as SQLSchema<'a, &'a str, SQLiteValue<'a>>>::TYPE;
        const SQL: SQL<'a, SQLiteValue<'a>> = SQL::empty();
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            <UsersId as SQLSchema<'a, &'a str, SQLiteValue<'a>>>::SQL
        }
    }
    impl<'a, V: SQLParam + 'a> ToSQL<'a, V> for AliasedUsersId {
        fn to_sql(&self) -> SQL<'a, V> {
            SQL::raw(
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "\"{0}\".\"{1}\"",
                            self.alias,
                            SQLColumnInfo::name(self),
                        ),
                    )
                }),
            )
        }
    }
    impl<'a> ::std::convert::Into<SQLiteValue<'a>> for AliasedUsersId {
        fn into(self) -> SQLiteValue<'a> {
            let column_ref = ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "\"{0}\".\"{1}\"",
                        self.alias,
                        SQLColumnInfo::name(&self),
                    ),
                )
            });
            SQLiteValue::Text(::std::borrow::Cow::Owned(column_ref))
        }
    }
    #[allow(non_upper_case_globals, dead_code)]
    pub struct AliasedUsersName {
        alias: &'static str,
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::fmt::Debug for AliasedUsersName {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "AliasedUsersName",
                "alias",
                &&self.alias,
            )
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::clone::Clone for AliasedUsersName {
        #[inline]
        fn clone(&self) -> AliasedUsersName {
            let _: ::core::clone::AssertParamIsClone<&'static str>;
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::Copy for AliasedUsersName {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::default::Default for AliasedUsersName {
        #[inline]
        fn default() -> AliasedUsersName {
            AliasedUsersName {
                alias: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialOrd for AliasedUsersName {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AliasedUsersName,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.alias, &other.alias)
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Ord for AliasedUsersName {
        #[inline]
        fn cmp(&self, other: &AliasedUsersName) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.alias, &other.alias)
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Eq for AliasedUsersName {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'static str>;
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::StructuralPartialEq for AliasedUsersName {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialEq for AliasedUsersName {
        #[inline]
        fn eq(&self, other: &AliasedUsersName) -> bool {
            self.alias == other.alias
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::hash::Hash for AliasedUsersName {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.alias, state)
        }
    }
    impl AliasedUsersName {
        pub const fn new(alias: &'static str) -> Self {
            Self { alias }
        }
    }
    impl SQLColumnInfo for AliasedUsersName {
        fn name(&self) -> &str {
            static ORIGINAL_FIELD: UsersName = UsersName::new();
            <UsersName as SQLColumnInfo>::name(&ORIGINAL_FIELD)
        }
        fn r#type(&self) -> &str {
            static ORIGINAL_FIELD: UsersName = UsersName::new();
            <UsersName as SQLColumnInfo>::r#type(&ORIGINAL_FIELD)
        }
        fn is_primary_key(&self) -> bool {
            static ORIGINAL_FIELD: UsersName = UsersName::new();
            <UsersName as SQLColumnInfo>::is_primary_key(&ORIGINAL_FIELD)
        }
        fn is_not_null(&self) -> bool {
            static ORIGINAL_FIELD: UsersName = UsersName::new();
            <UsersName as SQLColumnInfo>::is_not_null(&ORIGINAL_FIELD)
        }
        fn is_unique(&self) -> bool {
            static ORIGINAL_FIELD: UsersName = UsersName::new();
            <UsersName as SQLColumnInfo>::is_unique(&ORIGINAL_FIELD)
        }
        fn has_default(&self) -> bool {
            static ORIGINAL_FIELD: UsersName = UsersName::new();
            <UsersName as SQLColumnInfo>::has_default(&ORIGINAL_FIELD)
        }
        fn table(&self) -> &dyn SQLTableInfo {
            static ORIGINAL_TABLE: Users = Users::new();
            &ORIGINAL_TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLColumnInfo> {
            static ORIGINAL_FIELD: UsersName = UsersName::new();
            <UsersName as SQLColumnInfo>::foreign_key(&ORIGINAL_FIELD)
        }
    }
    impl SQLiteColumnInfo for AliasedUsersName {
        fn is_autoincrement(&self) -> bool {
            static ORIGINAL_FIELD: UsersName = UsersName::new();
            <UsersName as SQLiteColumnInfo>::is_autoincrement(&ORIGINAL_FIELD)
        }
        fn table(&self) -> &dyn SQLiteTableInfo {
            static ORIGINAL_FIELD: UsersName = UsersName::new();
            <UsersName as SQLiteColumnInfo>::table(&ORIGINAL_FIELD)
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLiteColumnInfo> {
            static ORIGINAL_FIELD: UsersName = UsersName::new();
            <UsersName as SQLiteColumnInfo>::foreign_key(&ORIGINAL_FIELD)
        }
    }
    impl<'a> SQLColumn<'a, SQLiteValue<'a>> for AliasedUsersName {
        type Table = AliasedUsers;
        type TableType = <UsersName as SQLColumn<'a, SQLiteValue<'a>>>::TableType;
        type Type = <UsersName as SQLColumn<'a, SQLiteValue<'a>>>::Type;
        const PRIMARY_KEY: bool = <UsersName as SQLColumn<
            'a,
            SQLiteValue<'a>,
        >>::PRIMARY_KEY;
        const NOT_NULL: bool = <UsersName as SQLColumn<'a, SQLiteValue<'a>>>::NOT_NULL;
        const UNIQUE: bool = <UsersName as SQLColumn<'a, SQLiteValue<'a>>>::UNIQUE;
        const DEFAULT: Option<Self::Type> = <UsersName as SQLColumn<
            'a,
            SQLiteValue<'a>,
        >>::DEFAULT;
        fn default_fn(&'a self) -> Option<impl Fn() -> Self::Type> {
            static ORIGINAL_FIELD: UsersName = UsersName::new();
            ORIGINAL_FIELD.default_fn()
        }
    }
    impl<'a> SQLiteColumn<'a> for AliasedUsersName {
        const AUTOINCREMENT: bool = <UsersName as SQLiteColumn<'a>>::AUTOINCREMENT;
    }
    impl<'a> SQLSchema<'a, &'a str, SQLiteValue<'a>> for AliasedUsersName {
        const NAME: &'a str = <UsersName as SQLSchema<
            'a,
            &'a str,
            SQLiteValue<'a>,
        >>::NAME;
        const TYPE: &'a str = <UsersName as SQLSchema<
            'a,
            &'a str,
            SQLiteValue<'a>,
        >>::TYPE;
        const SQL: SQL<'a, SQLiteValue<'a>> = SQL::empty();
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            <UsersName as SQLSchema<'a, &'a str, SQLiteValue<'a>>>::SQL
        }
    }
    impl<'a, V: SQLParam + 'a> ToSQL<'a, V> for AliasedUsersName {
        fn to_sql(&self) -> SQL<'a, V> {
            SQL::raw(
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "\"{0}\".\"{1}\"",
                            self.alias,
                            SQLColumnInfo::name(self),
                        ),
                    )
                }),
            )
        }
    }
    impl<'a> ::std::convert::Into<SQLiteValue<'a>> for AliasedUsersName {
        fn into(self) -> SQLiteValue<'a> {
            let column_ref = ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "\"{0}\".\"{1}\"",
                        self.alias,
                        SQLColumnInfo::name(&self),
                    ),
                )
            });
            SQLiteValue::Text(::std::borrow::Cow::Owned(column_ref))
        }
    }
    #[allow(non_upper_case_globals, dead_code)]
    pub struct AliasedUsersAge {
        alias: &'static str,
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::fmt::Debug for AliasedUsersAge {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "AliasedUsersAge",
                "alias",
                &&self.alias,
            )
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::clone::Clone for AliasedUsersAge {
        #[inline]
        fn clone(&self) -> AliasedUsersAge {
            let _: ::core::clone::AssertParamIsClone<&'static str>;
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::Copy for AliasedUsersAge {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::default::Default for AliasedUsersAge {
        #[inline]
        fn default() -> AliasedUsersAge {
            AliasedUsersAge {
                alias: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialOrd for AliasedUsersAge {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AliasedUsersAge,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.alias, &other.alias)
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Ord for AliasedUsersAge {
        #[inline]
        fn cmp(&self, other: &AliasedUsersAge) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.alias, &other.alias)
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Eq for AliasedUsersAge {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'static str>;
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::StructuralPartialEq for AliasedUsersAge {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialEq for AliasedUsersAge {
        #[inline]
        fn eq(&self, other: &AliasedUsersAge) -> bool {
            self.alias == other.alias
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::hash::Hash for AliasedUsersAge {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.alias, state)
        }
    }
    impl AliasedUsersAge {
        pub const fn new(alias: &'static str) -> Self {
            Self { alias }
        }
    }
    impl SQLColumnInfo for AliasedUsersAge {
        fn name(&self) -> &str {
            static ORIGINAL_FIELD: UsersAge = UsersAge::new();
            <UsersAge as SQLColumnInfo>::name(&ORIGINAL_FIELD)
        }
        fn r#type(&self) -> &str {
            static ORIGINAL_FIELD: UsersAge = UsersAge::new();
            <UsersAge as SQLColumnInfo>::r#type(&ORIGINAL_FIELD)
        }
        fn is_primary_key(&self) -> bool {
            static ORIGINAL_FIELD: UsersAge = UsersAge::new();
            <UsersAge as SQLColumnInfo>::is_primary_key(&ORIGINAL_FIELD)
        }
        fn is_not_null(&self) -> bool {
            static ORIGINAL_FIELD: UsersAge = UsersAge::new();
            <UsersAge as SQLColumnInfo>::is_not_null(&ORIGINAL_FIELD)
        }
        fn is_unique(&self) -> bool {
            static ORIGINAL_FIELD: UsersAge = UsersAge::new();
            <UsersAge as SQLColumnInfo>::is_unique(&ORIGINAL_FIELD)
        }
        fn has_default(&self) -> bool {
            static ORIGINAL_FIELD: UsersAge = UsersAge::new();
            <UsersAge as SQLColumnInfo>::has_default(&ORIGINAL_FIELD)
        }
        fn table(&self) -> &dyn SQLTableInfo {
            static ORIGINAL_TABLE: Users = Users::new();
            &ORIGINAL_TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLColumnInfo> {
            static ORIGINAL_FIELD: UsersAge = UsersAge::new();
            <UsersAge as SQLColumnInfo>::foreign_key(&ORIGINAL_FIELD)
        }
    }
    impl SQLiteColumnInfo for AliasedUsersAge {
        fn is_autoincrement(&self) -> bool {
            static ORIGINAL_FIELD: UsersAge = UsersAge::new();
            <UsersAge as SQLiteColumnInfo>::is_autoincrement(&ORIGINAL_FIELD)
        }
        fn table(&self) -> &dyn SQLiteTableInfo {
            static ORIGINAL_FIELD: UsersAge = UsersAge::new();
            <UsersAge as SQLiteColumnInfo>::table(&ORIGINAL_FIELD)
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLiteColumnInfo> {
            static ORIGINAL_FIELD: UsersAge = UsersAge::new();
            <UsersAge as SQLiteColumnInfo>::foreign_key(&ORIGINAL_FIELD)
        }
    }
    impl<'a> SQLColumn<'a, SQLiteValue<'a>> for AliasedUsersAge {
        type Table = AliasedUsers;
        type TableType = <UsersAge as SQLColumn<'a, SQLiteValue<'a>>>::TableType;
        type Type = <UsersAge as SQLColumn<'a, SQLiteValue<'a>>>::Type;
        const PRIMARY_KEY: bool = <UsersAge as SQLColumn<
            'a,
            SQLiteValue<'a>,
        >>::PRIMARY_KEY;
        const NOT_NULL: bool = <UsersAge as SQLColumn<'a, SQLiteValue<'a>>>::NOT_NULL;
        const UNIQUE: bool = <UsersAge as SQLColumn<'a, SQLiteValue<'a>>>::UNIQUE;
        const DEFAULT: Option<Self::Type> = <UsersAge as SQLColumn<
            'a,
            SQLiteValue<'a>,
        >>::DEFAULT;
        fn default_fn(&'a self) -> Option<impl Fn() -> Self::Type> {
            static ORIGINAL_FIELD: UsersAge = UsersAge::new();
            ORIGINAL_FIELD.default_fn()
        }
    }
    impl<'a> SQLiteColumn<'a> for AliasedUsersAge {
        const AUTOINCREMENT: bool = <UsersAge as SQLiteColumn<'a>>::AUTOINCREMENT;
    }
    impl<'a> SQLSchema<'a, &'a str, SQLiteValue<'a>> for AliasedUsersAge {
        const NAME: &'a str = <UsersAge as SQLSchema<
            'a,
            &'a str,
            SQLiteValue<'a>,
        >>::NAME;
        const TYPE: &'a str = <UsersAge as SQLSchema<
            'a,
            &'a str,
            SQLiteValue<'a>,
        >>::TYPE;
        const SQL: SQL<'a, SQLiteValue<'a>> = SQL::empty();
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            <UsersAge as SQLSchema<'a, &'a str, SQLiteValue<'a>>>::SQL
        }
    }
    impl<'a, V: SQLParam + 'a> ToSQL<'a, V> for AliasedUsersAge {
        fn to_sql(&self) -> SQL<'a, V> {
            SQL::raw(
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "\"{0}\".\"{1}\"",
                            self.alias,
                            SQLColumnInfo::name(self),
                        ),
                    )
                }),
            )
        }
    }
    impl<'a> ::std::convert::Into<SQLiteValue<'a>> for AliasedUsersAge {
        fn into(self) -> SQLiteValue<'a> {
            let column_ref = ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "\"{0}\".\"{1}\"",
                        self.alias,
                        SQLColumnInfo::name(&self),
                    ),
                )
            });
            SQLiteValue::Text(::std::borrow::Cow::Owned(column_ref))
        }
    }
    #[allow(non_upper_case_globals, dead_code)]
    pub struct AliasedUsers {
        alias: &'static str,
        pub id: AliasedUsersId,
        pub name: AliasedUsersName,
        pub age: AliasedUsersAge,
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::default::Default for AliasedUsers {
        #[inline]
        fn default() -> AliasedUsers {
            AliasedUsers {
                alias: ::core::default::Default::default(),
                id: ::core::default::Default::default(),
                name: ::core::default::Default::default(),
                age: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::clone::Clone for AliasedUsers {
        #[inline]
        fn clone(&self) -> AliasedUsers {
            let _: ::core::clone::AssertParamIsClone<&'static str>;
            let _: ::core::clone::AssertParamIsClone<AliasedUsersId>;
            let _: ::core::clone::AssertParamIsClone<AliasedUsersName>;
            let _: ::core::clone::AssertParamIsClone<AliasedUsersAge>;
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::Copy for AliasedUsers {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::fmt::Debug for AliasedUsers {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "AliasedUsers",
                "alias",
                &self.alias,
                "id",
                &self.id,
                "name",
                &self.name,
                "age",
                &&self.age,
            )
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::StructuralPartialEq for AliasedUsers {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialEq for AliasedUsers {
        #[inline]
        fn eq(&self, other: &AliasedUsers) -> bool {
            self.alias == other.alias && self.id == other.id && self.name == other.name
                && self.age == other.age
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Eq for AliasedUsers {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'static str>;
            let _: ::core::cmp::AssertParamIsEq<AliasedUsersId>;
            let _: ::core::cmp::AssertParamIsEq<AliasedUsersName>;
            let _: ::core::cmp::AssertParamIsEq<AliasedUsersAge>;
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::hash::Hash for AliasedUsers {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.alias, state);
            ::core::hash::Hash::hash(&self.id, state);
            ::core::hash::Hash::hash(&self.name, state);
            ::core::hash::Hash::hash(&self.age, state)
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialOrd for AliasedUsers {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AliasedUsers,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.alias, &other.alias) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(&self.id, &other.id) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.name,
                                &other.name,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(&self.age, &other.age)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Ord for AliasedUsers {
        #[inline]
        fn cmp(&self, other: &AliasedUsers) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.alias, &other.alias) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.id, &other.id) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.name, &other.name) {
                                ::core::cmp::Ordering::Equal => {
                                    ::core::cmp::Ord::cmp(&self.age, &other.age)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    impl AliasedUsers {
        pub const fn new(alias: &'static str) -> Self {
            Self {
                alias,
                id: AliasedUsersId::new(alias),
                name: AliasedUsersName::new(alias),
                age: AliasedUsersAge::new(alias),
            }
        }
    }
    impl SQLTableInfo for AliasedUsers {
        fn name(&self) -> &str {
            self.alias
        }
        fn columns(&self) -> &'static [&'static dyn SQLColumnInfo] {
            static ORIGINAL_TABLE: Users = Users::new();
            <Users as SQLTableInfo>::columns(&ORIGINAL_TABLE)
        }
        fn dependencies(&self) -> Box<[&'static dyn SQLTableInfo]> {
            SQLTableInfo::columns(self)
                .iter()
                .filter_map(|col| SQLColumnInfo::foreign_key(*col))
                .map(|fk_col| SQLColumnInfo::table(fk_col))
                .collect()
        }
    }
    impl SQLiteTableInfo for AliasedUsers {
        fn r#type(&self) -> &SQLiteSchemaType {
            static ORIGINAL_TABLE: Users = Users::new();
            SQLiteTableInfo::r#type(&ORIGINAL_TABLE)
        }
        fn strict(&self) -> bool {
            static ORIGINAL_TABLE: Users = Users::new();
            SQLiteTableInfo::strict(&ORIGINAL_TABLE)
        }
        fn without_rowid(&self) -> bool {
            static ORIGINAL_TABLE: Users = Users::new();
            SQLiteTableInfo::without_rowid(&ORIGINAL_TABLE)
        }
        fn sqlite_columns(&self) -> &'static [&'static dyn SQLiteColumnInfo] {
            static ORIGINAL_TABLE: Users = Users::new();
            <Users as SQLiteTableInfo>::sqlite_columns(&ORIGINAL_TABLE)
        }
        fn sqlite_dependencies(&self) -> Box<[&'static dyn SQLiteTableInfo]> {
            SQLiteTableInfo::sqlite_columns(self)
                .iter()
                .filter_map(|col| SQLiteColumnInfo::foreign_key(*col))
                .map(|fk_col| SQLiteColumnInfo::table(fk_col))
                .collect()
        }
    }
    impl<'a> SQLTable<'a, SQLiteSchemaType, SQLiteValue<'a>> for AliasedUsers {
        type Select = <Users as SQLTable<'a, SQLiteSchemaType, SQLiteValue<'a>>>::Select;
        type Insert<T> = <Users as SQLTable<
            'a,
            SQLiteSchemaType,
            SQLiteValue<'a>,
        >>::Insert<T>;
        type Update = <Users as SQLTable<'a, SQLiteSchemaType, SQLiteValue<'a>>>::Update;
        type Aliased = AliasedUsers;
        fn alias(name: &'static str) -> Self::Aliased {
            AliasedUsers::new(name)
        }
    }
    impl<'a> SQLiteTable<'a> for AliasedUsers {
        const WITHOUT_ROWID: bool = <Users as SQLiteTable<'a>>::WITHOUT_ROWID;
        const STRICT: bool = <Users as SQLiteTable<'a>>::STRICT;
    }
    impl<'a> SQLSchema<'a, SQLiteSchemaType, SQLiteValue<'a>> for AliasedUsers {
        const NAME: &'a str = <Users as SQLSchema<
            'a,
            SQLiteSchemaType,
            SQLiteValue<'a>,
        >>::NAME;
        const TYPE: SQLiteSchemaType = <Users as SQLSchema<
            'a,
            SQLiteSchemaType,
            SQLiteValue<'a>,
        >>::TYPE;
        const SQL: SQL<'a, SQLiteValue<'a>> = <Users as SQLSchema<
            'a,
            SQLiteSchemaType,
            SQLiteValue<'a>,
        >>::SQL;
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            {
                static INSTANCE: Users = Users::new();
                <Users as SQLSchema<
                    'a,
                    SQLiteSchemaType,
                    SQLiteValue<'a>,
                >>::sql(&INSTANCE)
            }
        }
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for AliasedUsers {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            static ORIGINAL_TABLE: Users = Users::new();
            ORIGINAL_TABLE.to_sql().alias(self.alias)
        }
    }
    impl Users {
        pub const fn alias(alias: &'static str) -> AliasedUsers {
            AliasedUsers::new(alias)
        }
    }
    impl ::std::convert::TryFrom<&::rusqlite::Row<'_>> for SelectUsers {
        type Error = DrizzleError;
        fn try_from(
            row: &::rusqlite::Row<'_>,
        ) -> ::std::result::Result<Self, Self::Error> {
            Ok(Self {
                id: {
                    let value_ref = row.get_ref("id")?;
                    <Uuid as FromSQLiteValue>::from_value_ref(value_ref)?
                },
                name: {
                    let value_ref = row.get_ref("name")?;
                    <String as FromSQLiteValue>::from_value_ref(value_ref)?
                },
                age: {
                    let value_ref = row.get_ref("age")?;
                    <u64 as FromSQLiteValue>::from_value_ref(value_ref)?
                },
            })
        }
    }
    impl ::std::convert::TryFrom<&::rusqlite::Row<'_>> for PartialSelectUsers {
        type Error = DrizzleError;
        fn try_from(
            row: &::rusqlite::Row<'_>,
        ) -> ::std::result::Result<Self, Self::Error> {
            Ok(Self {
                id: {
                    let value_ref = row
                        .get_ref("id")
                        .unwrap_or(::rusqlite::types::ValueRef::Null);
                    match value_ref {
                        ::rusqlite::types::ValueRef::Null => None,
                        _ => <Uuid as FromSQLiteValue>::from_value_ref(value_ref).ok(),
                    }
                },
                name: {
                    let value_ref = row
                        .get_ref("name")
                        .unwrap_or(::rusqlite::types::ValueRef::Null);
                    match value_ref {
                        ::rusqlite::types::ValueRef::Null => None,
                        _ => <String as FromSQLiteValue>::from_value_ref(value_ref).ok(),
                    }
                },
                age: {
                    let value_ref = row
                        .get_ref("age")
                        .unwrap_or(::rusqlite::types::ValueRef::Null);
                    match value_ref {
                        ::rusqlite::types::ValueRef::Null => None,
                        _ => <u64 as FromSQLiteValue>::from_value_ref(value_ref).ok(),
                    }
                },
            })
        }
    }
    impl ::std::convert::TryFrom<&::rusqlite::Row<'_>> for UpdateUsers {
        type Error = DrizzleError;
        fn try_from(
            row: &::rusqlite::Row<'_>,
        ) -> ::std::result::Result<Self, Self::Error> {
            Ok(Self {
                id: {
                    let value_ref = row.get_ref("id")?;
                    Some(<Uuid as FromSQLiteValue>::from_value_ref(value_ref)?)
                },
                name: {
                    let value_ref = row.get_ref("name")?;
                    Some(<String as FromSQLiteValue>::from_value_ref(value_ref)?)
                },
                age: {
                    let value_ref = row.get_ref("age")?;
                    Some(<u64 as FromSQLiteValue>::from_value_ref(value_ref)?)
                },
            })
        }
    }
    impl ::std::convert::TryFrom<&::libsql::Row> for SelectUsers {
        type Error = DrizzleError;
        fn try_from(row: &::libsql::Row) -> ::std::result::Result<Self, Self::Error> {
            Ok(Self {
                id: row.get::<[u8; 16]>(0i32).map(::uuid::Uuid::from_bytes)?,
                name: row.get::<String>(1i32)?,
                age: row.get::<i64>(2i32).map(TryInto::try_into)??,
            })
        }
    }
    impl ::std::convert::TryFrom<&::libsql::Row> for UpdateUsers {
        type Error = DrizzleError;
        fn try_from(row: &::libsql::Row) -> ::std::result::Result<Self, Self::Error> {
            Ok(Self {
                id: row
                    .get::<Option<[u8; 16]>>(0i32)
                    .map(|opt| opt.map(::uuid::Uuid::from_bytes))?,
                name: row.get::<Option<String>>(1i32)?,
                age: row
                    .get::<Option<i64>>(2i32)
                    .map(|opt| opt.and_then(|v| v.try_into().ok()))?,
            })
        }
    }
    pub struct Posts {
        pub id: PostsId,
        pub user_id: PostsUserId,
        pub context: PostsContext,
    }
    #[automatically_derived]
    impl ::core::default::Default for Posts {
        #[inline]
        fn default() -> Posts {
            Posts {
                id: ::core::default::Default::default(),
                user_id: ::core::default::Default::default(),
                context: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Posts {
        #[inline]
        fn clone(&self) -> Posts {
            let _: ::core::clone::AssertParamIsClone<PostsId>;
            let _: ::core::clone::AssertParamIsClone<PostsUserId>;
            let _: ::core::clone::AssertParamIsClone<PostsContext>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Posts {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Posts {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Posts",
                "id",
                &self.id,
                "user_id",
                &self.user_id,
                "context",
                &&self.context,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Posts {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Posts {
        #[inline]
        fn eq(&self, other: &Posts) -> bool {
            self.id == other.id && self.user_id == other.user_id
                && self.context == other.context
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Posts {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<PostsId>;
            let _: ::core::cmp::AssertParamIsEq<PostsUserId>;
            let _: ::core::cmp::AssertParamIsEq<PostsContext>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Posts {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.id, state);
            ::core::hash::Hash::hash(&self.user_id, state);
            ::core::hash::Hash::hash(&self.context, state)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Posts {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Posts,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.id, &other.id) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.user_id,
                        &other.user_id,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.context,
                                &other.context,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Posts {
        #[inline]
        fn cmp(&self, other: &Posts) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.id, &other.id) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.user_id, &other.user_id) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.context, &other.context)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    impl Posts {
        /// Table metadata in drizzle-kit compatible JSON format.
        ///
        /// This constant contains the schema metadata for migrations,
        /// matching the format used by drizzle-kit snapshots.
        pub const __DRIZZLE_TABLE_META: &'static str = "{\"name\":\"posts\",\"columns\":{\"context\":{\"name\":\"context\",\"type\":\"text\",\"primaryKey\":false,\"notNull\":false},\"id\":{\"name\":\"id\",\"type\":\"blob\",\"primaryKey\":true,\"notNull\":true},\"user_id\":{\"name\":\"user_id\",\"type\":\"blob\",\"primaryKey\":false,\"notNull\":true}},\"indexes\":{},\"foreignKeys\":{\"posts_user_id_Users_id_fk\":{\"name\":\"posts_user_id_Users_id_fk\",\"tableFrom\":\"posts\",\"columnsFrom\":[\"user_id\"],\"tableTo\":\"Users\",\"columnsTo\":[\"id\"],\"onUpdate\":\"no action\",\"onDelete\":\"no action\"}},\"compositePrimaryKeys\":{},\"uniqueConstraints\":{},\"checkConstraints\":{}}";
    }
    #[allow(non_upper_case_globals)]
    impl Posts {
        pub const fn new() -> Self {
            Self {
                id: PostsId,
                user_id: PostsUserId,
                context: PostsContext,
            }
        }
        pub const id: PostsId = PostsId;
        pub const user_id: PostsUserId = PostsUserId;
        pub const context: PostsContext = PostsContext;
    }
    #[allow(non_camel_case_types)]
    pub struct PostsId;
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::fmt::Debug for PostsId {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "PostsId")
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for PostsId {
        #[inline]
        fn clone(&self) -> PostsId {
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::marker::Copy for PostsId {}
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::default::Default for PostsId {
        #[inline]
        fn default() -> PostsId {
            PostsId {}
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialOrd for PostsId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &PostsId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::Ord for PostsId {
        #[inline]
        fn cmp(&self, other: &PostsId) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::Eq for PostsId {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::marker::StructuralPartialEq for PostsId {}
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialEq for PostsId {
        #[inline]
        fn eq(&self, other: &PostsId) -> bool {
            true
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::hash::Hash for PostsId {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl PostsId {
        pub const fn new() -> PostsId {
            PostsId
        }
    }
    impl<'a> SQLSchema<'a, &'a str, SQLiteValue<'a>> for PostsId {
        const NAME: &'a str = "id";
        const TYPE: &'a str = "BLOB";
        const SQL: SQL<'a, SQLiteValue<'a>> = SQL::empty();
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            SQL::raw("id BLOB PRIMARY KEY NOT NULL")
        }
    }
    impl SQLColumnInfo for PostsId {
        fn name(&self) -> &str {
            <Self as SQLSchema<'_, &'static str, SQLiteValue<'_>>>::NAME
        }
        fn r#type(&self) -> &str {
            <Self as SQLSchema<'_, &'static str, SQLiteValue<'_>>>::TYPE
        }
        fn is_primary_key(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::PRIMARY_KEY
        }
        fn is_not_null(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::NOT_NULL
        }
        fn is_unique(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::UNIQUE
        }
        fn has_default(&self) -> bool {
            true
        }
        fn table(&self) -> &dyn SQLTableInfo {
            static TABLE: Posts = Posts::new();
            &TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLColumnInfo> {
            None
        }
    }
    impl SQLiteColumnInfo for PostsId {
        fn is_autoincrement(&self) -> bool {
            <Self as SQLiteColumn<'_>>::AUTOINCREMENT
        }
        fn table(&self) -> &dyn SQLiteTableInfo {
            static TABLE: Posts = Posts::new();
            &TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLiteColumnInfo> {
            None
        }
    }
    impl<'a> SQLColumn<'a, SQLiteValue<'a>> for PostsId {
        type Table = Posts;
        type TableType = SQLiteSchemaType;
        type Type = Uuid;
        const PRIMARY_KEY: bool = true;
        const NOT_NULL: bool = true;
        const UNIQUE: bool = false;
        const DEFAULT: Option<Self::Type> = None;
        fn default_fn(&'a self) -> Option<impl Fn() -> Self::Type> {
            Some(Uuid::new_v4)
        }
    }
    impl<'a> SQLiteColumn<'a> for PostsId {
        const AUTOINCREMENT: bool = false;
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for PostsId {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            static INSTANCE: PostsId = PostsId;
            SQL::column(&INSTANCE)
        }
    }
    impl<'a> ::std::convert::Into<SQLiteValue<'a>> for PostsId {
        fn into(self) -> SQLiteValue<'a> {
            SQLiteValue::Text(::std::borrow::Cow::Borrowed("id"))
        }
    }
    #[allow(non_camel_case_types)]
    pub struct PostsUserId;
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::fmt::Debug for PostsUserId {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "PostsUserId")
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for PostsUserId {
        #[inline]
        fn clone(&self) -> PostsUserId {
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::marker::Copy for PostsUserId {}
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::default::Default for PostsUserId {
        #[inline]
        fn default() -> PostsUserId {
            PostsUserId {}
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialOrd for PostsUserId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &PostsUserId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::Ord for PostsUserId {
        #[inline]
        fn cmp(&self, other: &PostsUserId) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::Eq for PostsUserId {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::marker::StructuralPartialEq for PostsUserId {}
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialEq for PostsUserId {
        #[inline]
        fn eq(&self, other: &PostsUserId) -> bool {
            true
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::hash::Hash for PostsUserId {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl PostsUserId {
        pub const fn new() -> PostsUserId {
            PostsUserId
        }
    }
    impl<'a> SQLSchema<'a, &'a str, SQLiteValue<'a>> for PostsUserId {
        const NAME: &'a str = "user_id";
        const TYPE: &'a str = "BLOB";
        const SQL: SQL<'a, SQLiteValue<'a>> = SQL::empty();
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            SQL::raw("user_id BLOB NOT NULL")
        }
    }
    impl SQLColumnInfo for PostsUserId {
        fn name(&self) -> &str {
            <Self as SQLSchema<'_, &'static str, SQLiteValue<'_>>>::NAME
        }
        fn r#type(&self) -> &str {
            <Self as SQLSchema<'_, &'static str, SQLiteValue<'_>>>::TYPE
        }
        fn is_primary_key(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::PRIMARY_KEY
        }
        fn is_not_null(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::NOT_NULL
        }
        fn is_unique(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::UNIQUE
        }
        fn has_default(&self) -> bool {
            false
        }
        fn table(&self) -> &dyn SQLTableInfo {
            static TABLE: Posts = Posts::new();
            &TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLColumnInfo> {
            #[allow(non_upper_case_globals)]
            static FK_COLUMN: UsersId = UsersId::new();
            Some(&FK_COLUMN)
        }
    }
    impl SQLiteColumnInfo for PostsUserId {
        fn is_autoincrement(&self) -> bool {
            <Self as SQLiteColumn<'_>>::AUTOINCREMENT
        }
        fn table(&self) -> &dyn SQLiteTableInfo {
            static TABLE: Posts = Posts::new();
            &TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLiteColumnInfo> {
            #[allow(non_upper_case_globals)]
            static FK_COLUMN: UsersId = UsersId::new();
            Some(&FK_COLUMN)
        }
    }
    impl<'a> SQLColumn<'a, SQLiteValue<'a>> for PostsUserId {
        type Table = Posts;
        type TableType = SQLiteSchemaType;
        type Type = Uuid;
        const PRIMARY_KEY: bool = false;
        const NOT_NULL: bool = true;
        const UNIQUE: bool = false;
        const DEFAULT: Option<Self::Type> = None;
        fn default_fn(&'a self) -> Option<impl Fn() -> Self::Type> {
            None::<fn() -> Self::Type>
        }
    }
    impl<'a> SQLiteColumn<'a> for PostsUserId {
        const AUTOINCREMENT: bool = false;
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for PostsUserId {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            static INSTANCE: PostsUserId = PostsUserId;
            SQL::column(&INSTANCE)
        }
    }
    impl<'a> ::std::convert::Into<SQLiteValue<'a>> for PostsUserId {
        fn into(self) -> SQLiteValue<'a> {
            SQLiteValue::Text(::std::borrow::Cow::Borrowed("user_id"))
        }
    }
    #[allow(non_camel_case_types)]
    pub struct PostsContext;
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::fmt::Debug for PostsContext {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "PostsContext")
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for PostsContext {
        #[inline]
        fn clone(&self) -> PostsContext {
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::marker::Copy for PostsContext {}
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::default::Default for PostsContext {
        #[inline]
        fn default() -> PostsContext {
            PostsContext {}
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialOrd for PostsContext {
        #[inline]
        fn partial_cmp(
            &self,
            other: &PostsContext,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::Ord for PostsContext {
        #[inline]
        fn cmp(&self, other: &PostsContext) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::Eq for PostsContext {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::marker::StructuralPartialEq for PostsContext {}
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialEq for PostsContext {
        #[inline]
        fn eq(&self, other: &PostsContext) -> bool {
            true
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::hash::Hash for PostsContext {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl PostsContext {
        pub const fn new() -> PostsContext {
            PostsContext
        }
    }
    impl<'a> SQLSchema<'a, &'a str, SQLiteValue<'a>> for PostsContext {
        const NAME: &'a str = "context";
        const TYPE: &'a str = "TEXT";
        const SQL: SQL<'a, SQLiteValue<'a>> = SQL::empty();
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            SQL::raw("context TEXT")
        }
    }
    impl SQLColumnInfo for PostsContext {
        fn name(&self) -> &str {
            <Self as SQLSchema<'_, &'static str, SQLiteValue<'_>>>::NAME
        }
        fn r#type(&self) -> &str {
            <Self as SQLSchema<'_, &'static str, SQLiteValue<'_>>>::TYPE
        }
        fn is_primary_key(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::PRIMARY_KEY
        }
        fn is_not_null(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::NOT_NULL
        }
        fn is_unique(&self) -> bool {
            <Self as SQLColumn<'_, SQLiteValue<'_>>>::UNIQUE
        }
        fn has_default(&self) -> bool {
            false
        }
        fn table(&self) -> &dyn SQLTableInfo {
            static TABLE: Posts = Posts::new();
            &TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLColumnInfo> {
            None
        }
    }
    impl SQLiteColumnInfo for PostsContext {
        fn is_autoincrement(&self) -> bool {
            <Self as SQLiteColumn<'_>>::AUTOINCREMENT
        }
        fn table(&self) -> &dyn SQLiteTableInfo {
            static TABLE: Posts = Posts::new();
            &TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLiteColumnInfo> {
            None
        }
    }
    impl<'a> SQLColumn<'a, SQLiteValue<'a>> for PostsContext {
        type Table = Posts;
        type TableType = SQLiteSchemaType;
        type Type = Option<String>;
        const PRIMARY_KEY: bool = false;
        const NOT_NULL: bool = false;
        const UNIQUE: bool = false;
        const DEFAULT: Option<Self::Type> = None;
        fn default_fn(&'a self) -> Option<impl Fn() -> Self::Type> {
            None::<fn() -> Self::Type>
        }
    }
    impl<'a> SQLiteColumn<'a> for PostsContext {
        const AUTOINCREMENT: bool = false;
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for PostsContext {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            static INSTANCE: PostsContext = PostsContext;
            SQL::column(&INSTANCE)
        }
    }
    impl<'a> ::std::convert::Into<SQLiteValue<'a>> for PostsContext {
        fn into(self) -> SQLiteValue<'a> {
            SQLiteValue::Text(::std::borrow::Cow::Borrowed("context"))
        }
    }
    impl<'a> SQLSchema<'a, SQLiteSchemaType, SQLiteValue<'a>> for Posts {
        const NAME: &'a str = "posts";
        const TYPE: SQLiteSchemaType = {
            #[allow(non_upper_case_globals)]
            static TABLE_INSTANCE: Posts = Posts::new();
            SQLiteSchemaType::Table(&TABLE_INSTANCE)
        };
        const SQL: SQL<'a, SQLiteValue<'a>> = SQL::empty();
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            let runtime_sql = {
                let column_defs = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        "id BLOB PRIMARY KEY NOT NULL".to_string(),
                        {
                            let base_def = "user_id BLOB NOT NULL";
                            let table_name = Users::NAME.to_string();
                            let column_name = <_ as SQLColumnInfo>::name(&Users::id)
                                .to_string();
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "{0} REFERENCES {1}({2})",
                                        base_def,
                                        table_name,
                                        column_name,
                                    ),
                                )
                            })
                        },
                        "context TEXT".to_string(),
                    ]),
                );
                let mut column_defs_str = column_defs.join(", ");
                let mut sql = ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "CREATE TABLE \"{0}\" ({1})",
                            "posts",
                            column_defs_str,
                        ),
                    )
                });
                sql.push(';');
                sql
            };
            SQL::raw(runtime_sql)
        }
    }
    impl<'a> SQLTable<'a, SQLiteSchemaType, SQLiteValue<'a>> for Posts {
        type Select = SelectPosts;
        type Insert<T> = InsertPosts<'a, T>;
        type Update = UpdatePosts;
        type Aliased = AliasedPosts;
        fn alias(name: &'static str) -> Self::Aliased {
            AliasedPosts::new(name)
        }
    }
    impl SQLTableInfo for Posts {
        fn name(&self) -> &str {
            <Self as SQLSchema<'_, SQLiteSchemaType, SQLiteValue<'_>>>::NAME
        }
        fn columns(&self) -> &'static [&'static dyn SQLColumnInfo] {
            #[allow(non_upper_case_globals)]
            static PostsId: PostsId = PostsId::new();
            #[allow(non_upper_case_globals)]
            static PostsUserId: PostsUserId = PostsUserId::new();
            #[allow(non_upper_case_globals)]
            static PostsContext: PostsContext = PostsContext::new();
            #[allow(non_upper_case_globals)]
            static COLUMNS: [&'static dyn SQLColumnInfo; 3usize] = [
                &PostsId,
                &PostsUserId,
                &PostsContext,
            ];
            &COLUMNS
        }
        fn dependencies(&self) -> Box<[&'static dyn SQLTableInfo]> {
            SQLTableInfo::columns(self)
                .iter()
                .filter_map(|col| SQLColumnInfo::foreign_key(*col))
                .map(|fk_col| SQLColumnInfo::table(fk_col))
                .collect()
        }
    }
    impl SQLiteTableInfo for Posts {
        fn r#type(&self) -> &SQLiteSchemaType {
            &<Self as SQLSchema<'_, SQLiteSchemaType, SQLiteValue<'_>>>::TYPE
        }
        fn strict(&self) -> bool {
            false
        }
        fn without_rowid(&self) -> bool {
            false
        }
        fn sqlite_columns(&self) -> &'static [&'static dyn SQLiteColumnInfo] {
            #[allow(non_upper_case_globals)]
            static PostsId: PostsId = PostsId::new();
            #[allow(non_upper_case_globals)]
            static PostsUserId: PostsUserId = PostsUserId::new();
            #[allow(non_upper_case_globals)]
            static PostsContext: PostsContext = PostsContext::new();
            #[allow(non_upper_case_globals)]
            static SQLITE_COLUMNS: [&'static dyn SQLiteColumnInfo; 3usize] = [
                &PostsId,
                &PostsUserId,
                &PostsContext,
            ];
            &SQLITE_COLUMNS
        }
        fn sqlite_dependencies(&self) -> Box<[&'static dyn SQLiteTableInfo]> {
            SQLiteTableInfo::sqlite_columns(self)
                .iter()
                .filter_map(|col| SQLiteColumnInfo::foreign_key(*col))
                .map(|fk_col| SQLiteColumnInfo::table(fk_col))
                .collect()
        }
    }
    impl<'a> SQLiteTable<'a> for Posts {
        const WITHOUT_ROWID: bool = false;
        const STRICT: bool = false;
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for Posts {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            static INSTANCE: Posts = Posts::new();
            SQL::table(&INSTANCE)
        }
    }
    pub struct SelectPosts {
        pub id: Uuid,
        pub user_id: Uuid,
        pub context: ::std::option::Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SelectPosts {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "SelectPosts",
                "id",
                &self.id,
                "user_id",
                &self.user_id,
                "context",
                &&self.context,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SelectPosts {
        #[inline]
        fn clone(&self) -> SelectPosts {
            SelectPosts {
                id: ::core::clone::Clone::clone(&self.id),
                user_id: ::core::clone::Clone::clone(&self.user_id),
                context: ::core::clone::Clone::clone(&self.context),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SelectPosts {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SelectPosts {
        #[inline]
        fn eq(&self, other: &SelectPosts) -> bool {
            self.id == other.id && self.user_id == other.user_id
                && self.context == other.context
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for SelectPosts {
        #[inline]
        fn default() -> SelectPosts {
            SelectPosts {
                id: ::core::default::Default::default(),
                user_id: ::core::default::Default::default(),
                context: ::core::default::Default::default(),
            }
        }
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for SelectPosts {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            ::core::panicking::panic("not implemented")
        }
    }
    pub struct PartialSelectPosts {
        pub id: Option<Uuid>,
        pub user_id: Option<Uuid>,
        pub context: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PartialSelectPosts {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "PartialSelectPosts",
                "id",
                &self.id,
                "user_id",
                &self.user_id,
                "context",
                &&self.context,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PartialSelectPosts {
        #[inline]
        fn clone(&self) -> PartialSelectPosts {
            PartialSelectPosts {
                id: ::core::clone::Clone::clone(&self.id),
                user_id: ::core::clone::Clone::clone(&self.user_id),
                context: ::core::clone::Clone::clone(&self.context),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PartialSelectPosts {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PartialSelectPosts {
        #[inline]
        fn eq(&self, other: &PartialSelectPosts) -> bool {
            self.id == other.id && self.user_id == other.user_id
                && self.context == other.context
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for PartialSelectPosts {
        #[inline]
        fn default() -> PartialSelectPosts {
            PartialSelectPosts {
                id: ::core::default::Default::default(),
                user_id: ::core::default::Default::default(),
                context: ::core::default::Default::default(),
            }
        }
    }
    impl PartialSelectPosts {
        pub fn with_id<T: Into<::uuid::Uuid>>(mut self, value: T) -> Self {
            let value = value.into();
            self.id = Some(value);
            self
        }
        pub fn with_user_id<T: Into<::uuid::Uuid>>(mut self, value: T) -> Self {
            let value = value.into();
            self.user_id = Some(value);
            self
        }
        pub fn with_context<T: Into<::std::string::String>>(mut self, value: T) -> Self {
            let value = value.into();
            self.context = Some(value);
            self
        }
    }
    impl<'a> SQLPartial<'a, SQLiteValue<'a>> for SelectPosts {
        type Partial = PartialSelectPosts;
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for PartialSelectPosts {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            ::core::panicking::panic("not implemented")
        }
    }
    pub struct PostsIdSet;
    pub struct PostsIdNotSet;
    pub struct PostsUserIdSet;
    pub struct PostsUserIdNotSet;
    pub struct PostsContextSet;
    pub struct PostsContextNotSet;
    pub struct InsertPosts<
        'a,
        T = (PostsIdNotSet, PostsUserIdNotSet, PostsContextNotSet),
    > {
        id: SQLiteInsertValue<'a, SQLiteValue<'a>, ::uuid::Uuid>,
        user_id: SQLiteInsertValue<'a, SQLiteValue<'a>, ::uuid::Uuid>,
        context: SQLiteInsertValue<'a, SQLiteValue<'a>, ::std::string::String>,
        _pattern: ::std::marker::PhantomData<T>,
    }
    #[automatically_derived]
    impl<'a, T: ::core::fmt::Debug> ::core::fmt::Debug for InsertPosts<'a, T> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "InsertPosts",
                "id",
                &self.id,
                "user_id",
                &self.user_id,
                "context",
                &self.context,
                "_pattern",
                &&self._pattern,
            )
        }
    }
    #[automatically_derived]
    impl<'a, T: ::core::clone::Clone> ::core::clone::Clone for InsertPosts<'a, T> {
        #[inline]
        fn clone(&self) -> InsertPosts<'a, T> {
            InsertPosts {
                id: ::core::clone::Clone::clone(&self.id),
                user_id: ::core::clone::Clone::clone(&self.user_id),
                context: ::core::clone::Clone::clone(&self.context),
                _pattern: ::core::clone::Clone::clone(&self._pattern),
            }
        }
    }
    impl<'a, T> Default for InsertPosts<'a, T> {
        fn default() -> Self {
            Self {
                id: ((Uuid::new_v4)()).into(),
                user_id: SQLiteInsertValue::Omit,
                context: SQLiteInsertValue::Omit,
                _pattern: ::std::marker::PhantomData,
            }
        }
    }
    impl<'a> InsertPosts<'a, (PostsIdNotSet, PostsUserIdNotSet, PostsContextNotSet)> {
        pub fn new(
            user_id: impl Into<SQLiteInsertValue<'a, SQLiteValue<'a>, ::uuid::Uuid>>,
        ) -> InsertPosts<'a, (PostsIdNotSet, PostsUserIdSet, PostsContextNotSet)> {
            InsertPosts {
                user_id: user_id.into(),
                ..Default::default()
            }
        }
    }
    impl<'a, T> InsertPosts<'a, T> {
        /// Converts this insert model to an owned version with 'static lifetime
        pub fn into_owned(self) -> InsertPosts<'static, T> {
            InsertPosts {
                id: self.id.into_owned(),
                user_id: self.user_id.into_owned(),
                context: self.context.into_owned(),
                _pattern: ::std::marker::PhantomData,
            }
        }
    }
    impl<
        'a,
        PostsId,
        PostsUserId,
        PostsContext,
    > InsertPosts<'a, (PostsId, PostsUserId, PostsContext)> {
        pub fn with_id<V>(
            self,
            value: V,
        ) -> InsertPosts<'a, (PostsIdSet, PostsUserId, PostsContext)>
        where
            V: Into<SQLiteInsertValue<'a, SQLiteValue<'a>, ::uuid::Uuid>>,
        {
            InsertPosts {
                id: value.into(),
                user_id: self.user_id,
                context: self.context,
                _pattern: ::std::marker::PhantomData,
            }
        }
    }
    impl<
        'a,
        PostsId,
        PostsUserId,
        PostsContext,
    > InsertPosts<'a, (PostsId, PostsUserId, PostsContext)> {
        pub fn with_user_id<V>(
            self,
            value: V,
        ) -> InsertPosts<'a, (PostsId, PostsUserIdSet, PostsContext)>
        where
            V: Into<SQLiteInsertValue<'a, SQLiteValue<'a>, ::uuid::Uuid>>,
        {
            InsertPosts {
                id: self.id,
                user_id: value.into(),
                context: self.context,
                _pattern: ::std::marker::PhantomData,
            }
        }
    }
    impl<
        'a,
        PostsId,
        PostsUserId,
        PostsContext,
    > InsertPosts<'a, (PostsId, PostsUserId, PostsContext)> {
        pub fn with_context<V>(
            self,
            value: V,
        ) -> InsertPosts<'a, (PostsId, PostsUserId, PostsContextSet)>
        where
            V: Into<SQLiteInsertValue<'a, SQLiteValue<'a>, ::std::string::String>>,
        {
            InsertPosts {
                id: self.id,
                user_id: self.user_id,
                context: value.into(),
                _pattern: ::std::marker::PhantomData,
            }
        }
    }
    impl<'a, T> ToSQL<'a, SQLiteValue<'a>> for InsertPosts<'a, T> {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            SQLModel::values(self)
        }
    }
    impl<'a, T> SQLModel<'a, SQLiteValue<'a>> for InsertPosts<'a, T> {
        type Columns = Box<[&'static dyn SQLColumnInfo]>;
        fn columns(&self) -> Self::Columns {
            static TABLE: Posts = Posts::new();
            let all_columns = SQLTableInfo::columns(&TABLE);
            let mut result_columns = Vec::new();
            match &self.id {
                SQLiteInsertValue::Omit => {}
                _ => {
                    result_columns.push(all_columns[0usize]);
                }
            }
            match &self.user_id {
                SQLiteInsertValue::Omit => {}
                _ => {
                    result_columns.push(all_columns[1usize]);
                }
            }
            match &self.context {
                SQLiteInsertValue::Omit => {}
                _ => {
                    result_columns.push(all_columns[2usize]);
                }
            }
            result_columns.into_boxed_slice()
        }
        fn values(&self) -> SQL<'a, SQLiteValue<'a>> {
            let mut sql_parts = Vec::new();
            match &self.id {
                SQLiteInsertValue::Omit => {}
                SQLiteInsertValue::Null => {
                    sql_parts.push(SQL::param(SQLiteValue::Null));
                }
                SQLiteInsertValue::Value(wrapper) => {
                    sql_parts.push(wrapper.value.clone());
                }
            }
            match &self.user_id {
                SQLiteInsertValue::Omit => {}
                SQLiteInsertValue::Null => {
                    sql_parts.push(SQL::param(SQLiteValue::Null));
                }
                SQLiteInsertValue::Value(wrapper) => {
                    sql_parts.push(wrapper.value.clone());
                }
            }
            match &self.context {
                SQLiteInsertValue::Omit => {}
                SQLiteInsertValue::Null => {
                    sql_parts.push(SQL::param(SQLiteValue::Null));
                }
                SQLiteInsertValue::Value(wrapper) => {
                    sql_parts.push(wrapper.value.clone());
                }
            }
            SQL::join(sql_parts, Token::COMMA)
        }
    }
    pub struct UpdatePosts {
        pub id: ::std::option::Option<Uuid>,
        pub user_id: ::std::option::Option<Uuid>,
        pub context: ::std::option::Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UpdatePosts {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "UpdatePosts",
                "id",
                &self.id,
                "user_id",
                &self.user_id,
                "context",
                &&self.context,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UpdatePosts {
        #[inline]
        fn clone(&self) -> UpdatePosts {
            UpdatePosts {
                id: ::core::clone::Clone::clone(&self.id),
                user_id: ::core::clone::Clone::clone(&self.user_id),
                context: ::core::clone::Clone::clone(&self.context),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UpdatePosts {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UpdatePosts {
        #[inline]
        fn eq(&self, other: &UpdatePosts) -> bool {
            self.id == other.id && self.user_id == other.user_id
                && self.context == other.context
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for UpdatePosts {
        #[inline]
        fn default() -> UpdatePosts {
            UpdatePosts {
                id: ::core::default::Default::default(),
                user_id: ::core::default::Default::default(),
                context: ::core::default::Default::default(),
            }
        }
    }
    impl UpdatePosts {
        pub fn with_id<T: Into<::uuid::Uuid>>(mut self, value: T) -> Self {
            let value = value.into();
            self.id = Some(value);
            self
        }
        pub fn with_user_id<T: Into<::uuid::Uuid>>(mut self, value: T) -> Self {
            let value = value.into();
            self.user_id = Some(value);
            self
        }
        pub fn with_context<T: Into<::std::string::String>>(mut self, value: T) -> Self {
            let value = value.into();
            self.context = Some(value);
            self
        }
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for UpdatePosts {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            let mut assignments = Vec::new();
            if let Some(val) = &self.id {
                assignments
                    .push((
                        "id",
                        SQLiteValue::Blob(
                            ::std::borrow::Cow::Owned(val.as_bytes().to_vec()),
                        ),
                    ));
            }
            if let Some(val) = &self.user_id {
                assignments
                    .push((
                        "user_id",
                        SQLiteValue::Blob(
                            ::std::borrow::Cow::Owned(val.as_bytes().to_vec()),
                        ),
                    ));
            }
            if let Some(val) = &self.context {
                assignments
                    .push((
                        "context",
                        val.clone().try_into().unwrap_or(SQLiteValue::Null),
                    ));
            }
            SQL::assignments(assignments)
        }
    }
    impl<'a> SQLModel<'a, SQLiteValue<'a>> for SelectPosts {
        type Columns = &'static [&'static dyn SQLColumnInfo];
        fn columns(&self) -> Self::Columns {
            static INSTANCE: Posts = Posts::new();
            <Posts as SQLTableInfo>::columns(&INSTANCE)
        }
        fn values(&self) -> SQL<'a, SQLiteValue<'a>> {
            SQL::empty()
        }
    }
    impl<'a> SQLModel<'a, SQLiteValue<'a>> for UpdatePosts {
        type Columns = &'static [&'static dyn SQLColumnInfo];
        fn columns(&self) -> Self::Columns {
            static INSTANCE: Posts = Posts::new();
            <Posts as SQLTableInfo>::columns(&INSTANCE)
        }
        fn values(&self) -> SQL<'a, SQLiteValue<'a>> {
            let mut values = Vec::new();
            if let Some(val) = &self.id {
                values.push(val.clone().try_into().unwrap_or(SQLiteValue::Null));
            }
            if let Some(val) = &self.user_id {
                values.push(val.clone().try_into().unwrap_or(SQLiteValue::Null));
            }
            if let Some(val) = &self.context {
                values.push(val.clone().try_into().unwrap_or(SQLiteValue::Null));
            }
            SQL::param_list(values)
        }
    }
    impl<'a> SQLModel<'a, SQLiteValue<'a>> for PartialSelectPosts {
        type Columns = &'static [&'static dyn SQLColumnInfo];
        fn columns(&self) -> Self::Columns {
            static INSTANCE: Posts = Posts::new();
            <Posts as SQLTableInfo>::columns(&INSTANCE)
        }
        fn values(&self) -> SQL<'a, SQLiteValue<'a>> {
            SQL::empty()
        }
    }
    #[allow(non_upper_case_globals, dead_code)]
    pub struct AliasedPostsId {
        alias: &'static str,
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::fmt::Debug for AliasedPostsId {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "AliasedPostsId",
                "alias",
                &&self.alias,
            )
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::clone::Clone for AliasedPostsId {
        #[inline]
        fn clone(&self) -> AliasedPostsId {
            let _: ::core::clone::AssertParamIsClone<&'static str>;
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::Copy for AliasedPostsId {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::default::Default for AliasedPostsId {
        #[inline]
        fn default() -> AliasedPostsId {
            AliasedPostsId {
                alias: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialOrd for AliasedPostsId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AliasedPostsId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.alias, &other.alias)
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Ord for AliasedPostsId {
        #[inline]
        fn cmp(&self, other: &AliasedPostsId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.alias, &other.alias)
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Eq for AliasedPostsId {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'static str>;
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::StructuralPartialEq for AliasedPostsId {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialEq for AliasedPostsId {
        #[inline]
        fn eq(&self, other: &AliasedPostsId) -> bool {
            self.alias == other.alias
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::hash::Hash for AliasedPostsId {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.alias, state)
        }
    }
    impl AliasedPostsId {
        pub const fn new(alias: &'static str) -> Self {
            Self { alias }
        }
    }
    impl SQLColumnInfo for AliasedPostsId {
        fn name(&self) -> &str {
            static ORIGINAL_FIELD: PostsId = PostsId::new();
            <PostsId as SQLColumnInfo>::name(&ORIGINAL_FIELD)
        }
        fn r#type(&self) -> &str {
            static ORIGINAL_FIELD: PostsId = PostsId::new();
            <PostsId as SQLColumnInfo>::r#type(&ORIGINAL_FIELD)
        }
        fn is_primary_key(&self) -> bool {
            static ORIGINAL_FIELD: PostsId = PostsId::new();
            <PostsId as SQLColumnInfo>::is_primary_key(&ORIGINAL_FIELD)
        }
        fn is_not_null(&self) -> bool {
            static ORIGINAL_FIELD: PostsId = PostsId::new();
            <PostsId as SQLColumnInfo>::is_not_null(&ORIGINAL_FIELD)
        }
        fn is_unique(&self) -> bool {
            static ORIGINAL_FIELD: PostsId = PostsId::new();
            <PostsId as SQLColumnInfo>::is_unique(&ORIGINAL_FIELD)
        }
        fn has_default(&self) -> bool {
            static ORIGINAL_FIELD: PostsId = PostsId::new();
            <PostsId as SQLColumnInfo>::has_default(&ORIGINAL_FIELD)
        }
        fn table(&self) -> &dyn SQLTableInfo {
            static ORIGINAL_TABLE: Posts = Posts::new();
            &ORIGINAL_TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLColumnInfo> {
            static ORIGINAL_FIELD: PostsId = PostsId::new();
            <PostsId as SQLColumnInfo>::foreign_key(&ORIGINAL_FIELD)
        }
    }
    impl SQLiteColumnInfo for AliasedPostsId {
        fn is_autoincrement(&self) -> bool {
            static ORIGINAL_FIELD: PostsId = PostsId::new();
            <PostsId as SQLiteColumnInfo>::is_autoincrement(&ORIGINAL_FIELD)
        }
        fn table(&self) -> &dyn SQLiteTableInfo {
            static ORIGINAL_FIELD: PostsId = PostsId::new();
            <PostsId as SQLiteColumnInfo>::table(&ORIGINAL_FIELD)
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLiteColumnInfo> {
            static ORIGINAL_FIELD: PostsId = PostsId::new();
            <PostsId as SQLiteColumnInfo>::foreign_key(&ORIGINAL_FIELD)
        }
    }
    impl<'a> SQLColumn<'a, SQLiteValue<'a>> for AliasedPostsId {
        type Table = AliasedPosts;
        type TableType = <PostsId as SQLColumn<'a, SQLiteValue<'a>>>::TableType;
        type Type = <PostsId as SQLColumn<'a, SQLiteValue<'a>>>::Type;
        const PRIMARY_KEY: bool = <PostsId as SQLColumn<
            'a,
            SQLiteValue<'a>,
        >>::PRIMARY_KEY;
        const NOT_NULL: bool = <PostsId as SQLColumn<'a, SQLiteValue<'a>>>::NOT_NULL;
        const UNIQUE: bool = <PostsId as SQLColumn<'a, SQLiteValue<'a>>>::UNIQUE;
        const DEFAULT: Option<Self::Type> = <PostsId as SQLColumn<
            'a,
            SQLiteValue<'a>,
        >>::DEFAULT;
        fn default_fn(&'a self) -> Option<impl Fn() -> Self::Type> {
            static ORIGINAL_FIELD: PostsId = PostsId::new();
            ORIGINAL_FIELD.default_fn()
        }
    }
    impl<'a> SQLiteColumn<'a> for AliasedPostsId {
        const AUTOINCREMENT: bool = <PostsId as SQLiteColumn<'a>>::AUTOINCREMENT;
    }
    impl<'a> SQLSchema<'a, &'a str, SQLiteValue<'a>> for AliasedPostsId {
        const NAME: &'a str = <PostsId as SQLSchema<'a, &'a str, SQLiteValue<'a>>>::NAME;
        const TYPE: &'a str = <PostsId as SQLSchema<'a, &'a str, SQLiteValue<'a>>>::TYPE;
        const SQL: SQL<'a, SQLiteValue<'a>> = SQL::empty();
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            <PostsId as SQLSchema<'a, &'a str, SQLiteValue<'a>>>::SQL
        }
    }
    impl<'a, V: SQLParam + 'a> ToSQL<'a, V> for AliasedPostsId {
        fn to_sql(&self) -> SQL<'a, V> {
            SQL::raw(
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "\"{0}\".\"{1}\"",
                            self.alias,
                            SQLColumnInfo::name(self),
                        ),
                    )
                }),
            )
        }
    }
    impl<'a> ::std::convert::Into<SQLiteValue<'a>> for AliasedPostsId {
        fn into(self) -> SQLiteValue<'a> {
            let column_ref = ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "\"{0}\".\"{1}\"",
                        self.alias,
                        SQLColumnInfo::name(&self),
                    ),
                )
            });
            SQLiteValue::Text(::std::borrow::Cow::Owned(column_ref))
        }
    }
    #[allow(non_upper_case_globals, dead_code)]
    pub struct AliasedPostsUserId {
        alias: &'static str,
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::fmt::Debug for AliasedPostsUserId {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "AliasedPostsUserId",
                "alias",
                &&self.alias,
            )
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::clone::Clone for AliasedPostsUserId {
        #[inline]
        fn clone(&self) -> AliasedPostsUserId {
            let _: ::core::clone::AssertParamIsClone<&'static str>;
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::Copy for AliasedPostsUserId {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::default::Default for AliasedPostsUserId {
        #[inline]
        fn default() -> AliasedPostsUserId {
            AliasedPostsUserId {
                alias: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialOrd for AliasedPostsUserId {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AliasedPostsUserId,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.alias, &other.alias)
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Ord for AliasedPostsUserId {
        #[inline]
        fn cmp(&self, other: &AliasedPostsUserId) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.alias, &other.alias)
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Eq for AliasedPostsUserId {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'static str>;
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::StructuralPartialEq for AliasedPostsUserId {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialEq for AliasedPostsUserId {
        #[inline]
        fn eq(&self, other: &AliasedPostsUserId) -> bool {
            self.alias == other.alias
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::hash::Hash for AliasedPostsUserId {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.alias, state)
        }
    }
    impl AliasedPostsUserId {
        pub const fn new(alias: &'static str) -> Self {
            Self { alias }
        }
    }
    impl SQLColumnInfo for AliasedPostsUserId {
        fn name(&self) -> &str {
            static ORIGINAL_FIELD: PostsUserId = PostsUserId::new();
            <PostsUserId as SQLColumnInfo>::name(&ORIGINAL_FIELD)
        }
        fn r#type(&self) -> &str {
            static ORIGINAL_FIELD: PostsUserId = PostsUserId::new();
            <PostsUserId as SQLColumnInfo>::r#type(&ORIGINAL_FIELD)
        }
        fn is_primary_key(&self) -> bool {
            static ORIGINAL_FIELD: PostsUserId = PostsUserId::new();
            <PostsUserId as SQLColumnInfo>::is_primary_key(&ORIGINAL_FIELD)
        }
        fn is_not_null(&self) -> bool {
            static ORIGINAL_FIELD: PostsUserId = PostsUserId::new();
            <PostsUserId as SQLColumnInfo>::is_not_null(&ORIGINAL_FIELD)
        }
        fn is_unique(&self) -> bool {
            static ORIGINAL_FIELD: PostsUserId = PostsUserId::new();
            <PostsUserId as SQLColumnInfo>::is_unique(&ORIGINAL_FIELD)
        }
        fn has_default(&self) -> bool {
            static ORIGINAL_FIELD: PostsUserId = PostsUserId::new();
            <PostsUserId as SQLColumnInfo>::has_default(&ORIGINAL_FIELD)
        }
        fn table(&self) -> &dyn SQLTableInfo {
            static ORIGINAL_TABLE: Posts = Posts::new();
            &ORIGINAL_TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLColumnInfo> {
            static ORIGINAL_FIELD: PostsUserId = PostsUserId::new();
            <PostsUserId as SQLColumnInfo>::foreign_key(&ORIGINAL_FIELD)
        }
    }
    impl SQLiteColumnInfo for AliasedPostsUserId {
        fn is_autoincrement(&self) -> bool {
            static ORIGINAL_FIELD: PostsUserId = PostsUserId::new();
            <PostsUserId as SQLiteColumnInfo>::is_autoincrement(&ORIGINAL_FIELD)
        }
        fn table(&self) -> &dyn SQLiteTableInfo {
            static ORIGINAL_FIELD: PostsUserId = PostsUserId::new();
            <PostsUserId as SQLiteColumnInfo>::table(&ORIGINAL_FIELD)
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLiteColumnInfo> {
            static ORIGINAL_FIELD: PostsUserId = PostsUserId::new();
            <PostsUserId as SQLiteColumnInfo>::foreign_key(&ORIGINAL_FIELD)
        }
    }
    impl<'a> SQLColumn<'a, SQLiteValue<'a>> for AliasedPostsUserId {
        type Table = AliasedPosts;
        type TableType = <PostsUserId as SQLColumn<'a, SQLiteValue<'a>>>::TableType;
        type Type = <PostsUserId as SQLColumn<'a, SQLiteValue<'a>>>::Type;
        const PRIMARY_KEY: bool = <PostsUserId as SQLColumn<
            'a,
            SQLiteValue<'a>,
        >>::PRIMARY_KEY;
        const NOT_NULL: bool = <PostsUserId as SQLColumn<'a, SQLiteValue<'a>>>::NOT_NULL;
        const UNIQUE: bool = <PostsUserId as SQLColumn<'a, SQLiteValue<'a>>>::UNIQUE;
        const DEFAULT: Option<Self::Type> = <PostsUserId as SQLColumn<
            'a,
            SQLiteValue<'a>,
        >>::DEFAULT;
        fn default_fn(&'a self) -> Option<impl Fn() -> Self::Type> {
            static ORIGINAL_FIELD: PostsUserId = PostsUserId::new();
            ORIGINAL_FIELD.default_fn()
        }
    }
    impl<'a> SQLiteColumn<'a> for AliasedPostsUserId {
        const AUTOINCREMENT: bool = <PostsUserId as SQLiteColumn<'a>>::AUTOINCREMENT;
    }
    impl<'a> SQLSchema<'a, &'a str, SQLiteValue<'a>> for AliasedPostsUserId {
        const NAME: &'a str = <PostsUserId as SQLSchema<
            'a,
            &'a str,
            SQLiteValue<'a>,
        >>::NAME;
        const TYPE: &'a str = <PostsUserId as SQLSchema<
            'a,
            &'a str,
            SQLiteValue<'a>,
        >>::TYPE;
        const SQL: SQL<'a, SQLiteValue<'a>> = SQL::empty();
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            <PostsUserId as SQLSchema<'a, &'a str, SQLiteValue<'a>>>::SQL
        }
    }
    impl<'a, V: SQLParam + 'a> ToSQL<'a, V> for AliasedPostsUserId {
        fn to_sql(&self) -> SQL<'a, V> {
            SQL::raw(
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "\"{0}\".\"{1}\"",
                            self.alias,
                            SQLColumnInfo::name(self),
                        ),
                    )
                }),
            )
        }
    }
    impl<'a> ::std::convert::Into<SQLiteValue<'a>> for AliasedPostsUserId {
        fn into(self) -> SQLiteValue<'a> {
            let column_ref = ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "\"{0}\".\"{1}\"",
                        self.alias,
                        SQLColumnInfo::name(&self),
                    ),
                )
            });
            SQLiteValue::Text(::std::borrow::Cow::Owned(column_ref))
        }
    }
    #[allow(non_upper_case_globals, dead_code)]
    pub struct AliasedPostsContext {
        alias: &'static str,
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::fmt::Debug for AliasedPostsContext {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "AliasedPostsContext",
                "alias",
                &&self.alias,
            )
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::clone::Clone for AliasedPostsContext {
        #[inline]
        fn clone(&self) -> AliasedPostsContext {
            let _: ::core::clone::AssertParamIsClone<&'static str>;
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::Copy for AliasedPostsContext {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::default::Default for AliasedPostsContext {
        #[inline]
        fn default() -> AliasedPostsContext {
            AliasedPostsContext {
                alias: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialOrd for AliasedPostsContext {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AliasedPostsContext,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.alias, &other.alias)
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Ord for AliasedPostsContext {
        #[inline]
        fn cmp(&self, other: &AliasedPostsContext) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.alias, &other.alias)
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Eq for AliasedPostsContext {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'static str>;
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::StructuralPartialEq for AliasedPostsContext {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialEq for AliasedPostsContext {
        #[inline]
        fn eq(&self, other: &AliasedPostsContext) -> bool {
            self.alias == other.alias
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::hash::Hash for AliasedPostsContext {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.alias, state)
        }
    }
    impl AliasedPostsContext {
        pub const fn new(alias: &'static str) -> Self {
            Self { alias }
        }
    }
    impl SQLColumnInfo for AliasedPostsContext {
        fn name(&self) -> &str {
            static ORIGINAL_FIELD: PostsContext = PostsContext::new();
            <PostsContext as SQLColumnInfo>::name(&ORIGINAL_FIELD)
        }
        fn r#type(&self) -> &str {
            static ORIGINAL_FIELD: PostsContext = PostsContext::new();
            <PostsContext as SQLColumnInfo>::r#type(&ORIGINAL_FIELD)
        }
        fn is_primary_key(&self) -> bool {
            static ORIGINAL_FIELD: PostsContext = PostsContext::new();
            <PostsContext as SQLColumnInfo>::is_primary_key(&ORIGINAL_FIELD)
        }
        fn is_not_null(&self) -> bool {
            static ORIGINAL_FIELD: PostsContext = PostsContext::new();
            <PostsContext as SQLColumnInfo>::is_not_null(&ORIGINAL_FIELD)
        }
        fn is_unique(&self) -> bool {
            static ORIGINAL_FIELD: PostsContext = PostsContext::new();
            <PostsContext as SQLColumnInfo>::is_unique(&ORIGINAL_FIELD)
        }
        fn has_default(&self) -> bool {
            static ORIGINAL_FIELD: PostsContext = PostsContext::new();
            <PostsContext as SQLColumnInfo>::has_default(&ORIGINAL_FIELD)
        }
        fn table(&self) -> &dyn SQLTableInfo {
            static ORIGINAL_TABLE: Posts = Posts::new();
            &ORIGINAL_TABLE
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLColumnInfo> {
            static ORIGINAL_FIELD: PostsContext = PostsContext::new();
            <PostsContext as SQLColumnInfo>::foreign_key(&ORIGINAL_FIELD)
        }
    }
    impl SQLiteColumnInfo for AliasedPostsContext {
        fn is_autoincrement(&self) -> bool {
            static ORIGINAL_FIELD: PostsContext = PostsContext::new();
            <PostsContext as SQLiteColumnInfo>::is_autoincrement(&ORIGINAL_FIELD)
        }
        fn table(&self) -> &dyn SQLiteTableInfo {
            static ORIGINAL_FIELD: PostsContext = PostsContext::new();
            <PostsContext as SQLiteColumnInfo>::table(&ORIGINAL_FIELD)
        }
        fn foreign_key(&self) -> Option<&'static dyn SQLiteColumnInfo> {
            static ORIGINAL_FIELD: PostsContext = PostsContext::new();
            <PostsContext as SQLiteColumnInfo>::foreign_key(&ORIGINAL_FIELD)
        }
    }
    impl<'a> SQLColumn<'a, SQLiteValue<'a>> for AliasedPostsContext {
        type Table = AliasedPosts;
        type TableType = <PostsContext as SQLColumn<'a, SQLiteValue<'a>>>::TableType;
        type Type = <PostsContext as SQLColumn<'a, SQLiteValue<'a>>>::Type;
        const PRIMARY_KEY: bool = <PostsContext as SQLColumn<
            'a,
            SQLiteValue<'a>,
        >>::PRIMARY_KEY;
        const NOT_NULL: bool = <PostsContext as SQLColumn<
            'a,
            SQLiteValue<'a>,
        >>::NOT_NULL;
        const UNIQUE: bool = <PostsContext as SQLColumn<'a, SQLiteValue<'a>>>::UNIQUE;
        const DEFAULT: Option<Self::Type> = <PostsContext as SQLColumn<
            'a,
            SQLiteValue<'a>,
        >>::DEFAULT;
        fn default_fn(&'a self) -> Option<impl Fn() -> Self::Type> {
            static ORIGINAL_FIELD: PostsContext = PostsContext::new();
            ORIGINAL_FIELD.default_fn()
        }
    }
    impl<'a> SQLiteColumn<'a> for AliasedPostsContext {
        const AUTOINCREMENT: bool = <PostsContext as SQLiteColumn<'a>>::AUTOINCREMENT;
    }
    impl<'a> SQLSchema<'a, &'a str, SQLiteValue<'a>> for AliasedPostsContext {
        const NAME: &'a str = <PostsContext as SQLSchema<
            'a,
            &'a str,
            SQLiteValue<'a>,
        >>::NAME;
        const TYPE: &'a str = <PostsContext as SQLSchema<
            'a,
            &'a str,
            SQLiteValue<'a>,
        >>::TYPE;
        const SQL: SQL<'a, SQLiteValue<'a>> = SQL::empty();
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            <PostsContext as SQLSchema<'a, &'a str, SQLiteValue<'a>>>::SQL
        }
    }
    impl<'a, V: SQLParam + 'a> ToSQL<'a, V> for AliasedPostsContext {
        fn to_sql(&self) -> SQL<'a, V> {
            SQL::raw(
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "\"{0}\".\"{1}\"",
                            self.alias,
                            SQLColumnInfo::name(self),
                        ),
                    )
                }),
            )
        }
    }
    impl<'a> ::std::convert::Into<SQLiteValue<'a>> for AliasedPostsContext {
        fn into(self) -> SQLiteValue<'a> {
            let column_ref = ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "\"{0}\".\"{1}\"",
                        self.alias,
                        SQLColumnInfo::name(&self),
                    ),
                )
            });
            SQLiteValue::Text(::std::borrow::Cow::Owned(column_ref))
        }
    }
    #[allow(non_upper_case_globals, dead_code)]
    pub struct AliasedPosts {
        alias: &'static str,
        pub id: AliasedPostsId,
        pub user_id: AliasedPostsUserId,
        pub context: AliasedPostsContext,
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::default::Default for AliasedPosts {
        #[inline]
        fn default() -> AliasedPosts {
            AliasedPosts {
                alias: ::core::default::Default::default(),
                id: ::core::default::Default::default(),
                user_id: ::core::default::Default::default(),
                context: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::clone::Clone for AliasedPosts {
        #[inline]
        fn clone(&self) -> AliasedPosts {
            let _: ::core::clone::AssertParamIsClone<&'static str>;
            let _: ::core::clone::AssertParamIsClone<AliasedPostsId>;
            let _: ::core::clone::AssertParamIsClone<AliasedPostsUserId>;
            let _: ::core::clone::AssertParamIsClone<AliasedPostsContext>;
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::Copy for AliasedPosts {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::fmt::Debug for AliasedPosts {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "AliasedPosts",
                "alias",
                &self.alias,
                "id",
                &self.id,
                "user_id",
                &self.user_id,
                "context",
                &&self.context,
            )
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::marker::StructuralPartialEq for AliasedPosts {}
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialEq for AliasedPosts {
        #[inline]
        fn eq(&self, other: &AliasedPosts) -> bool {
            self.alias == other.alias && self.id == other.id
                && self.user_id == other.user_id && self.context == other.context
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Eq for AliasedPosts {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'static str>;
            let _: ::core::cmp::AssertParamIsEq<AliasedPostsId>;
            let _: ::core::cmp::AssertParamIsEq<AliasedPostsUserId>;
            let _: ::core::cmp::AssertParamIsEq<AliasedPostsContext>;
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::hash::Hash for AliasedPosts {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.alias, state);
            ::core::hash::Hash::hash(&self.id, state);
            ::core::hash::Hash::hash(&self.user_id, state);
            ::core::hash::Hash::hash(&self.context, state)
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::PartialOrd for AliasedPosts {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AliasedPosts,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.alias, &other.alias) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(&self.id, &other.id) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.user_id,
                                &other.user_id,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &self.context,
                                        &other.context,
                                    )
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    #[allow(non_upper_case_globals, dead_code)]
    impl ::core::cmp::Ord for AliasedPosts {
        #[inline]
        fn cmp(&self, other: &AliasedPosts) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.alias, &other.alias) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.id, &other.id) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.user_id, &other.user_id) {
                                ::core::cmp::Ordering::Equal => {
                                    ::core::cmp::Ord::cmp(&self.context, &other.context)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    impl AliasedPosts {
        pub const fn new(alias: &'static str) -> Self {
            Self {
                alias,
                id: AliasedPostsId::new(alias),
                user_id: AliasedPostsUserId::new(alias),
                context: AliasedPostsContext::new(alias),
            }
        }
    }
    impl SQLTableInfo for AliasedPosts {
        fn name(&self) -> &str {
            self.alias
        }
        fn columns(&self) -> &'static [&'static dyn SQLColumnInfo] {
            static ORIGINAL_TABLE: Posts = Posts::new();
            <Posts as SQLTableInfo>::columns(&ORIGINAL_TABLE)
        }
        fn dependencies(&self) -> Box<[&'static dyn SQLTableInfo]> {
            SQLTableInfo::columns(self)
                .iter()
                .filter_map(|col| SQLColumnInfo::foreign_key(*col))
                .map(|fk_col| SQLColumnInfo::table(fk_col))
                .collect()
        }
    }
    impl SQLiteTableInfo for AliasedPosts {
        fn r#type(&self) -> &SQLiteSchemaType {
            static ORIGINAL_TABLE: Posts = Posts::new();
            SQLiteTableInfo::r#type(&ORIGINAL_TABLE)
        }
        fn strict(&self) -> bool {
            static ORIGINAL_TABLE: Posts = Posts::new();
            SQLiteTableInfo::strict(&ORIGINAL_TABLE)
        }
        fn without_rowid(&self) -> bool {
            static ORIGINAL_TABLE: Posts = Posts::new();
            SQLiteTableInfo::without_rowid(&ORIGINAL_TABLE)
        }
        fn sqlite_columns(&self) -> &'static [&'static dyn SQLiteColumnInfo] {
            static ORIGINAL_TABLE: Posts = Posts::new();
            <Posts as SQLiteTableInfo>::sqlite_columns(&ORIGINAL_TABLE)
        }
        fn sqlite_dependencies(&self) -> Box<[&'static dyn SQLiteTableInfo]> {
            SQLiteTableInfo::sqlite_columns(self)
                .iter()
                .filter_map(|col| SQLiteColumnInfo::foreign_key(*col))
                .map(|fk_col| SQLiteColumnInfo::table(fk_col))
                .collect()
        }
    }
    impl<'a> SQLTable<'a, SQLiteSchemaType, SQLiteValue<'a>> for AliasedPosts {
        type Select = <Posts as SQLTable<'a, SQLiteSchemaType, SQLiteValue<'a>>>::Select;
        type Insert<T> = <Posts as SQLTable<
            'a,
            SQLiteSchemaType,
            SQLiteValue<'a>,
        >>::Insert<T>;
        type Update = <Posts as SQLTable<'a, SQLiteSchemaType, SQLiteValue<'a>>>::Update;
        type Aliased = AliasedPosts;
        fn alias(name: &'static str) -> Self::Aliased {
            AliasedPosts::new(name)
        }
    }
    impl<'a> SQLiteTable<'a> for AliasedPosts {
        const WITHOUT_ROWID: bool = <Posts as SQLiteTable<'a>>::WITHOUT_ROWID;
        const STRICT: bool = <Posts as SQLiteTable<'a>>::STRICT;
    }
    impl<'a> SQLSchema<'a, SQLiteSchemaType, SQLiteValue<'a>> for AliasedPosts {
        const NAME: &'a str = <Posts as SQLSchema<
            'a,
            SQLiteSchemaType,
            SQLiteValue<'a>,
        >>::NAME;
        const TYPE: SQLiteSchemaType = <Posts as SQLSchema<
            'a,
            SQLiteSchemaType,
            SQLiteValue<'a>,
        >>::TYPE;
        const SQL: SQL<'a, SQLiteValue<'a>> = <Posts as SQLSchema<
            'a,
            SQLiteSchemaType,
            SQLiteValue<'a>,
        >>::SQL;
        fn sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            {
                static INSTANCE: Posts = Posts::new();
                <Posts as SQLSchema<
                    'a,
                    SQLiteSchemaType,
                    SQLiteValue<'a>,
                >>::sql(&INSTANCE)
            }
        }
    }
    impl<'a> ToSQL<'a, SQLiteValue<'a>> for AliasedPosts {
        fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
            static ORIGINAL_TABLE: Posts = Posts::new();
            ORIGINAL_TABLE.to_sql().alias(self.alias)
        }
    }
    impl Posts {
        pub const fn alias(alias: &'static str) -> AliasedPosts {
            AliasedPosts::new(alias)
        }
    }
    impl ::std::convert::TryFrom<&::rusqlite::Row<'_>> for SelectPosts {
        type Error = DrizzleError;
        fn try_from(
            row: &::rusqlite::Row<'_>,
        ) -> ::std::result::Result<Self, Self::Error> {
            Ok(Self {
                id: {
                    let value_ref = row.get_ref("id")?;
                    <Uuid as FromSQLiteValue>::from_value_ref(value_ref)?
                },
                user_id: {
                    let value_ref = row.get_ref("user_id")?;
                    <Uuid as FromSQLiteValue>::from_value_ref(value_ref)?
                },
                context: {
                    let value_ref = row.get_ref("context")?;
                    match value_ref {
                        ::rusqlite::types::ValueRef::Null => None,
                        _ => {
                            Some(<String as FromSQLiteValue>::from_value_ref(value_ref)?)
                        }
                    }
                },
            })
        }
    }
    impl ::std::convert::TryFrom<&::rusqlite::Row<'_>> for PartialSelectPosts {
        type Error = DrizzleError;
        fn try_from(
            row: &::rusqlite::Row<'_>,
        ) -> ::std::result::Result<Self, Self::Error> {
            Ok(Self {
                id: {
                    let value_ref = row
                        .get_ref("id")
                        .unwrap_or(::rusqlite::types::ValueRef::Null);
                    match value_ref {
                        ::rusqlite::types::ValueRef::Null => None,
                        _ => <Uuid as FromSQLiteValue>::from_value_ref(value_ref).ok(),
                    }
                },
                user_id: {
                    let value_ref = row
                        .get_ref("user_id")
                        .unwrap_or(::rusqlite::types::ValueRef::Null);
                    match value_ref {
                        ::rusqlite::types::ValueRef::Null => None,
                        _ => <Uuid as FromSQLiteValue>::from_value_ref(value_ref).ok(),
                    }
                },
                context: {
                    let value_ref = row
                        .get_ref("context")
                        .unwrap_or(::rusqlite::types::ValueRef::Null);
                    match value_ref {
                        ::rusqlite::types::ValueRef::Null => None,
                        _ => <String as FromSQLiteValue>::from_value_ref(value_ref).ok(),
                    }
                },
            })
        }
    }
    impl ::std::convert::TryFrom<&::rusqlite::Row<'_>> for UpdatePosts {
        type Error = DrizzleError;
        fn try_from(
            row: &::rusqlite::Row<'_>,
        ) -> ::std::result::Result<Self, Self::Error> {
            Ok(Self {
                id: {
                    let value_ref = row.get_ref("id")?;
                    Some(<Uuid as FromSQLiteValue>::from_value_ref(value_ref)?)
                },
                user_id: {
                    let value_ref = row.get_ref("user_id")?;
                    Some(<Uuid as FromSQLiteValue>::from_value_ref(value_ref)?)
                },
                context: {
                    let value_ref = row.get_ref("context")?;
                    Some(<String as FromSQLiteValue>::from_value_ref(value_ref)?)
                },
            })
        }
    }
    impl ::std::convert::TryFrom<&::libsql::Row> for SelectPosts {
        type Error = DrizzleError;
        fn try_from(row: &::libsql::Row) -> ::std::result::Result<Self, Self::Error> {
            Ok(Self {
                id: row.get::<[u8; 16]>(0i32).map(::uuid::Uuid::from_bytes)?,
                user_id: row.get::<[u8; 16]>(1i32).map(::uuid::Uuid::from_bytes)?,
                context: row.get::<Option<String>>(2i32)?,
            })
        }
    }
    impl ::std::convert::TryFrom<&::libsql::Row> for UpdatePosts {
        type Error = DrizzleError;
        fn try_from(row: &::libsql::Row) -> ::std::result::Result<Self, Self::Error> {
            Ok(Self {
                id: row
                    .get::<Option<[u8; 16]>>(0i32)
                    .map(|opt| opt.map(::uuid::Uuid::from_bytes))?,
                user_id: row
                    .get::<Option<[u8; 16]>>(1i32)
                    .map(|opt| opt.map(::uuid::Uuid::from_bytes))?,
                context: row.get::<Option<String>>(2i32)?,
            })
        }
    }
    pub struct Schema {
        pub users: Users,
        pub posts: Posts,
    }
    impl Default for Schema {
        fn default() -> Self {
            Self {
                users: Default::default(),
                posts: Default::default(),
            }
        }
    }
    impl Schema {
        pub const fn new() -> Self {
            Self {
                users: Users::new(),
                posts: Posts::new(),
            }
        }
        /// Get all schema items (tables and indexes) in field order
        pub fn items(&self) -> (&Users, &Posts) {
            (&self.users, &self.posts)
        }
    }
    impl SQLSchemaImpl for Schema {
        fn create_statements(&self) -> Vec<String> {
            let mut tables: Vec<(&str, String, &dyn SQLTableInfo)> = Vec::new();
            let mut indexes: std::collections::HashMap<&str, Vec<String>> = std::collections::HashMap::new();
            match <Users as SQLSchema<'_, SQLiteSchemaType, SQLiteValue<'_>>>::TYPE {
                SQLiteSchemaType::Table(table_info) => {
                    let table_name = SQLTableInfo::name(table_info);
                    let table_sql = <_ as SQLSchema<
                        '_,
                        SQLiteSchemaType,
                        SQLiteValue<'_>,
                    >>::sql(&self.users)
                        .sql();
                    tables.push((table_name, table_sql, table_info));
                }
                SQLiteSchemaType::Index(index_info) => {
                    let index_sql = <_ as SQLSchema<
                        '_,
                        SQLiteSchemaType,
                        SQLiteValue<'_>,
                    >>::sql(&self.users)
                        .sql();
                    let table_name = SQLIndexInfo::table(index_info).name();
                    indexes.entry(table_name).or_insert_with(Vec::new).push(index_sql);
                }
                SQLiteSchemaType::View => {}
                SQLiteSchemaType::Trigger => {}
            }
            match <Posts as SQLSchema<'_, SQLiteSchemaType, SQLiteValue<'_>>>::TYPE {
                SQLiteSchemaType::Table(table_info) => {
                    let table_name = SQLTableInfo::name(table_info);
                    let table_sql = <_ as SQLSchema<
                        '_,
                        SQLiteSchemaType,
                        SQLiteValue<'_>,
                    >>::sql(&self.posts)
                        .sql();
                    tables.push((table_name, table_sql, table_info));
                }
                SQLiteSchemaType::Index(index_info) => {
                    let index_sql = <_ as SQLSchema<
                        '_,
                        SQLiteSchemaType,
                        SQLiteValue<'_>,
                    >>::sql(&self.posts)
                        .sql();
                    let table_name = SQLIndexInfo::table(index_info).name();
                    indexes.entry(table_name).or_insert_with(Vec::new).push(index_sql);
                }
                SQLiteSchemaType::View => {}
                SQLiteSchemaType::Trigger => {}
            }
            tables
                .sort_by(|a, b| {
                    use std::cmp::Ordering;
                    let a_depends_on_b = SQLTableInfo::dependencies(a.2)
                        .iter()
                        .any(|dep| dep.name() == b.0);
                    let b_depends_on_a = SQLTableInfo::dependencies(b.2)
                        .iter()
                        .any(|dep| dep.name() == a.0);
                    match (a_depends_on_b, b_depends_on_a) {
                        (true, false) => Ordering::Greater,
                        (false, true) => Ordering::Less,
                        _ => a.0.cmp(b.0),
                    }
                });
            let mut sql_statements = Vec::<String>::new();
            for (table_name, table_sql, _) in tables {
                sql_statements.push(table_sql);
                if let Some(table_indexes) = indexes.get(table_name) {
                    for index_sql in table_indexes {
                        sql_statements.push(index_sql.clone());
                    }
                }
            }
            sql_statements
        }
    }
    impl From<Schema> for (Users, Posts) {
        fn from(schema: Schema) -> Self {
            (schema.users, schema.posts)
        }
    }
}
use drizzle::sqlite::prelude::*;
use rusqlite::Connection;
use uuid::Uuid;
use crate::schema::{
    InsertPosts, InsertUsers, Posts, Schema, SelectPosts, SelectUsers, Users,
};
fn main() {
    {
        use drizzle::core::eq;
        let conn = Connection::open_in_memory().expect("open connection");
        let (db, Schema { users, posts }) = drizzle::rusqlite::Drizzle::new(
            conn,
            Schema::new(),
        );
        db.create().expect("create tables");
        let id = Uuid::new_v4();
        db.insert(users)
            .values([InsertUsers::new("Alex Smith", 26u64).with_id(id)])
            .execute()
            .expect("insert user");
        db.insert(posts)
            .values([InsertPosts::new(id).with_context("just testing")])
            .execute()
            .expect("insert post");
        let user_rows: Vec<SelectUsers> = db
            .select(())
            .from(users)
            .all()
            .expect("select users");
        let post_rows: Vec<SelectPosts> = db
            .select(())
            .from(posts)
            .all()
            .expect("select posts");
        match (&user_rows.len(), &1) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&user_rows[0].name, &"Alex Smith") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&post_rows.len(), &1) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&post_rows[0].context, &Some("just testing".to_string())) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        {
            ::std::io::_print(format_args!("Users: {0:?}\n", user_rows));
        };
        {
            ::std::io::_print(format_args!("Posts: {0:?}\n", post_rows));
        };
        struct JoinedResult {
            #[column(Users::id)]
            id: Uuid,
            #[column(Posts::id)]
            post_id: Uuid,
            name: String,
            age: u64,
        }
        impl ::std::convert::TryFrom<&::rusqlite::Row<'_>> for JoinedResult {
            type Error = ::rusqlite::Error;
            fn try_from(
                row: &::rusqlite::Row<'_>,
            ) -> ::std::result::Result<Self, Self::Error> {
                Ok(Self {
                    id: row.get("id")?,
                    post_id: row.get("post_id")?,
                    name: row.get("name")?,
                    age: row.get("age")?,
                })
            }
        }
        impl ::std::convert::TryFrom<&::libsql::Row> for JoinedResult {
            type Error = DrizzleError;
            fn try_from(
                row: &::libsql::Row,
            ) -> ::std::result::Result<Self, Self::Error> {
                Ok(Self {
                    id: {
                        use DrizzleRow;
                        <_ as DrizzleRow>::get_column::<Uuid>(row, 0usize)
                    }?,
                    post_id: {
                        use DrizzleRow;
                        <_ as DrizzleRow>::get_column::<Uuid>(row, 1usize)
                    }?,
                    name: {
                        use DrizzleRow;
                        <_ as DrizzleRow>::get_column::<String>(row, 2usize)
                    }?,
                    age: {
                        use DrizzleRow;
                        <_ as DrizzleRow>::get_column::<u64>(row, 3usize)
                    }?,
                })
            }
        }
        impl<'a> ToSQL<'a, SQLiteValue<'a>> for JoinedResult {
            fn to_sql(&self) -> SQL<'a, SQLiteValue<'a>> {
                let mut columns = Vec::new();
                columns.push(Users::id.to_sql().alias("id"));
                columns.push(Posts::id.to_sql().alias("post_id"));
                columns.push(SQL::raw("name"));
                columns.push(SQL::raw("age"));
                SQL::join(columns, Token::COMMA)
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for JoinedResult {
            #[inline]
            fn default() -> JoinedResult {
                JoinedResult {
                    id: ::core::default::Default::default(),
                    post_id: ::core::default::Default::default(),
                    name: ::core::default::Default::default(),
                    age: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for JoinedResult {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "JoinedResult",
                    "id",
                    &self.id,
                    "post_id",
                    &self.post_id,
                    "name",
                    &self.name,
                    "age",
                    &&self.age,
                )
            }
        }
        let row: JoinedResult = db
            .select(JoinedResult::default())
            .from(users)
            .left_join(posts, eq(users.id, posts.user_id))
            .get()
            .expect("select users on posts.user_id");
        match (&row.id, &id) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&row.name, &"Alex Smith") {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        match (&row.age, &26) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        if !!row.post_id.is_nil() {
            ::core::panicking::panic("assertion failed: !row.post_id.is_nil()")
        }
    }
}
