//! Macro context and helper methods for SQLite table generation.
//!
//! Provides the MacroContext struct which holds all information needed
//! for code generation, along with helper methods that serve as the
//! single source of truth for field analysis decisions.

use crate::sqlite::field::{FieldInfo, SQLiteType, TypeCategory};
use proc_macro2::{Ident, TokenStream};
use quote::quote;
use syn::Visibility;

/// Context struct holding all information needed for macro generation.
///
/// This provides helper methods to reduce code duplication and improve maintainability
/// by centralizing decisions about field handling.
pub(crate) struct MacroContext<'a> {
    pub(crate) struct_ident: &'a Ident,
    pub(crate) struct_vis: &'a Visibility,
    pub(crate) table_name: String,
    pub(crate) create_table_sql: String,
    pub(crate) create_table_sql_runtime: Option<TokenStream>,
    pub(crate) field_infos: &'a [FieldInfo<'a>],
    pub(crate) select_model_ident: Ident,
    pub(crate) select_model_partial_ident: Ident,
    pub(crate) insert_model_ident: Ident,
    pub(crate) update_model_ident: Ident,
    pub(crate) without_rowid: bool,
    pub(crate) strict: bool,
    pub(crate) has_foreign_keys: bool,
}

/// Enum representing the different model types generated by the macro.
#[derive(Debug, Clone, Copy)]
pub(crate) enum ModelType {
    Insert,
    Update,
    PartialSelect,
}

impl<'a> MacroContext<'a> {
    // =========================================================================
    // Core Field Analysis Methods - Single Source of Truth
    // =========================================================================

    /// Determines if a field can auto-increment (INTEGER PRIMARY KEY in regular tables, excluding enums)
    pub(crate) fn can_field_autoincrement(&self, field: &FieldInfo) -> bool {
        if !field.is_primary || self.without_rowid || field.is_enum {
            return false;
        }
        matches!(field.column_type, SQLiteType::Integer)
    }

    /// Determines if a field should be optional in the Insert model
    pub(crate) fn is_field_optional_in_insert(&self, field: &FieldInfo) -> bool {
        // Nullable fields are always optional
        if field.is_nullable {
            return true;
        }

        // Fields with explicit defaults (SQL or runtime) are optional
        if field.has_default || field.default_fn.is_some() {
            return true;
        }

        // Primary key fields that can auto-increment are optional
        self.can_field_autoincrement(field)
    }

    // =========================================================================
    // Type Generation Methods - Using TypeCategory for consistency
    // =========================================================================

    /// Gets the appropriate field type for a specific model.
    ///
    /// Uses TypeCategory for consistent type handling across the codebase.
    pub(crate) fn get_field_type_for_model(
        &self,
        field: &FieldInfo,
        model_type: ModelType,
    ) -> TokenStream {
        let base_type = field.base_type;

        match model_type {
            ModelType::Insert => {
                // Use TypeCategory to determine the insert value type
                let insert_value_inner = field.insert_value_inner_type();
                quote!(::drizzle_sqlite::values::SQLiteInsertValue<'a, ::drizzle_sqlite::values::SQLiteValue<'a>, #insert_value_inner>)
            }
            ModelType::Update | ModelType::PartialSelect => {
                quote!(Option<#base_type>)
            }
        }
    }

    /// Gets the default value expression for insert model
    pub(crate) fn get_insert_default_value(&self, field: &FieldInfo) -> TokenStream {
        let name = field.ident;

        // Handle runtime function defaults (default_fn)
        if let Some(f) = &field.default_fn {
            return quote! { #name: ((#f)()).into() };
        }

        // Handle compile-time literal defaults (default = "value")
        if let Some(default_lit) = &field.default_value {
            return quote! { #name: (#default_lit).into() };
        }

        // Default to Omit so database can handle defaults
        quote! { #name: ::drizzle_sqlite::values::SQLiteInsertValue::Omit }
    }

    // =========================================================================
    // Field Conversion Methods
    // =========================================================================

    /// Generates field conversion for update ToSQL.
    ///
    /// Uses TypeCategory for consistent UUID and enum handling.
    pub(crate) fn get_update_field_conversion(&self, field: &FieldInfo) -> TokenStream {
        let name = field.ident;
        let column_name = &field.column_name;
        let category = field.type_category();

        // Handle UUID fields with type-aware conversion
        if matches!(category, TypeCategory::Uuid) {
            let uuid_conversion = match field.column_type {
                SQLiteType::Text => {
                    quote! { ::drizzle_sqlite::values::SQLiteValue::Text(::std::borrow::Cow::Owned(val.to_string())) }
                }
                SQLiteType::Blob => {
                    quote! { ::drizzle_sqlite::values::SQLiteValue::Blob(::std::borrow::Cow::Owned(val.as_bytes().to_vec())) }
                }
                _ => {
                    quote! { val.clone().try_into().unwrap_or(::drizzle_sqlite::values::SQLiteValue::Null) }
                }
            };

            return quote! {
                if let Some(val) = &self.#name {
                    assignments.push((#column_name, #uuid_conversion));
                }
            };
        }

        // Handle enum fields
        let conversion = if matches!(category, TypeCategory::Enum) {
            quote! { val.clone().into() }
        } else {
            quote! { val.clone().try_into().unwrap_or(::drizzle_sqlite::values::SQLiteValue::Null) }
        };

        quote! {
            if let Some(val) = &self.#name {
                assignments.push((#column_name, #conversion));
            }
        }
    }
}
