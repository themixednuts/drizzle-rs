//! Convenience method generation for model types.
//!
//! Generates `with_*` methods for Insert, Update, and PartialSelect models.

use super::super::context::{MacroContext, ModelType};
use crate::postgres::field::{FieldInfo, TypeCategory};
use heck::ToUpperCamelCase;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};

/// Generates a convenience method for a field based on its type
pub(crate) fn generate_convenience_method(
    field: &FieldInfo,
    model_type: ModelType,
    ctx: &MacroContext,
) -> TokenStream {
    let field_name = &field.ident;
    let base_type = &field.base_type;
    let method_name = format_ident!("with_{}", field_name);

    // Find the field index for pattern tracking
    let field_index = ctx
        .field_infos
        .iter()
        .position(|f| f.ident == field.ident)
        .expect("Field should exist in context");

    match model_type {
        ModelType::Insert => generate_insert_convenience_method(field, ctx, field_index),
        ModelType::Update => generate_update_convenience_method(field, base_type, &method_name, ctx),
        _ => generate_partial_select_convenience_method(field, base_type, &method_name),
    }
}

// =============================================================================
// Insert Model Convenience Methods
// =============================================================================

fn generate_insert_convenience_method(
    field: &FieldInfo,
    ctx: &MacroContext,
    field_index: usize,
) -> TokenStream {
    let field_name = &field.ident;
    let base_type = &field.base_type;
    let method_name = format_ident!("with_{}", field_name);
    let insert_model = &ctx.insert_model_ident;

    // Create generic parameters: field names as markers (UserName, UserEmail)
    let generic_params: Vec<_> = ctx
        .field_infos
        .iter()
        .map(|f| {
            let pascal = f.ident.to_string().to_upper_camel_case();
            format_ident!("{}{}", ctx.struct_ident, pascal)
        })
        .collect();

    // Create return type pattern: this field becomes Set, others stay generic
    let return_pattern_generics: Vec<_> = ctx
        .field_infos
        .iter()
        .enumerate()
        .map(|(i, f)| {
            let pascal = f.ident.to_string().to_upper_camel_case();
            if i == field_index {
                format_ident!("{}{}Set", ctx.struct_ident, pascal)
            } else {
                format_ident!("{}{}", ctx.struct_ident, pascal)
            }
        })
        .collect();

    // Generate field assignments - only update the specific field
    let field_assignments: Vec<_> = ctx
        .field_infos
        .iter()
        .enumerate()
        .map(|(i, f)| {
            let fname = &f.ident;
            if i == field_index {
                quote! { #fname: value.into() }
            } else {
                quote! { #fname: self.#fname }
            }
        })
        .collect();

    // Dispatch based on type category
    let category = field.type_category();

    match category {
        TypeCategory::String => {
            quote! {
                impl<'a, #(#generic_params),*> #insert_model<'a, (#(#generic_params),*)> {
                    pub fn #method_name<V>(self, value: V) -> #insert_model<'a, (#(#return_pattern_generics),*)>
                    where
                        V: Into<PostgresInsertValue<'a, PostgresValue<'a>, ::std::string::String>>
                    {
                        #insert_model {
                            #(#field_assignments,)*
                            _pattern: ::std::marker::PhantomData,
                        }
                    }
                }
            }
        }
        TypeCategory::Blob => {
            quote! {
                impl<'a, #(#generic_params),*> #insert_model<'a, (#(#generic_params),*)> {
                    pub fn #method_name<V>(self, value: V) -> #insert_model<'a, (#(#return_pattern_generics),*)>
                    where
                        V: Into<PostgresInsertValue<'a, PostgresValue<'a>, ::std::vec::Vec<u8>>>
                    {
                        #insert_model {
                            #(#field_assignments,)*
                            _pattern: ::std::marker::PhantomData,
                        }
                    }
                }
            }
        }
        // ArrayString, ArrayVec, Uuid, Json, Enum, and primitives use base type directly
        // Note: Custom JSON types now have TryInto<PostgresValue> impls generated by json.rs
        _ => {
            quote! {
                impl<'a, #(#generic_params),*> #insert_model<'a, (#(#generic_params),*)> {
                    pub fn #method_name<V>(self, value: V) -> #insert_model<'a, (#(#return_pattern_generics),*)>
                    where
                        V: Into<PostgresInsertValue<'a, PostgresValue<'a>, #base_type>>
                    {
                        #insert_model {
                            #(#field_assignments,)*
                            _pattern: ::std::marker::PhantomData,
                        }
                    }
                }
            }
        }
    }
}

// =============================================================================
// PartialSelect Model Convenience Methods
// =============================================================================

fn generate_partial_select_convenience_method(
    field: &FieldInfo,
    base_type: &syn::Type,
    method_name: &syn::Ident,
) -> TokenStream {
    let field_name = &field.ident;

    // PartialSelect methods are simple Option<T> setters, placed inside a shared impl block
    quote! {
        pub fn #method_name(mut self, value: #base_type) -> Self {
            self.#field_name = Some(value);
            self
        }
    }
}

// =============================================================================
// Update Model Convenience Methods
// =============================================================================

fn generate_update_convenience_method(
    field: &FieldInfo,
    base_type: &syn::Type,
    method_name: &syn::Ident,
    ctx: &MacroContext,
) -> TokenStream {
    let field_name = &field.ident;
    let update_model = &ctx.update_model_ident;
    let category = field.type_category();

    // Determine the inner type for the UpdateValue wrapper
    let inner_type = match category {
        TypeCategory::String => quote!(::std::string::String),
        TypeCategory::Blob => quote!(::std::vec::Vec<u8>),
        _ => quote!(#base_type),
    };

    // Each method in its own impl<'a> block so 'a is declared and used
    // within the same quote! invocation (matching the Insert pattern)
    quote! {
        impl<'a> #update_model<'a> {
            pub fn #method_name<V: Into<PostgresUpdateValue<'a, PostgresValue<'a>, #inner_type>>>(mut self, value: V) -> Self {
                self.#field_name = value.into();
                self
            }
        }
    }
}
